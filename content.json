{"pages":[],"posts":[{"title":"01.数据库用户相关操作","text":"创建用户12-- create user 用户名 identified by 密码create user scott identified by 123456 给用户赋予权限1234--赋予数据库登陆连接权限grant connect to scott;--赋予资源操作权限grant resource to scott;","link":"/2019/04/06/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"},{"title":"03.单行&amp;多行&amp;转换&amp;其他函数","text":"单行函数字符函数 函数 功能 示例 结果 INITCAP(char) 首字母大写 intitcap(‘hello’) Hello LOWER(char) 转换为小写 lower(‘FUN’) fun UPPER(char) 转换为大写 upper(‘sun’) SUN LTRIM(char,set) 左裁剪 ltrim(‘xyzadams’,’xyz’) adams RTRIM(charmset) 右裁剪 rtrim(‘xyzadams’,’ams’) xyzad TRANSLATE(char,from,to) 按字符翻译 translate(‘jack’,’abcd’,’1234’) j13k REPLACE(char,serch_str,replace_str) 字符串替换 ‘jack and jue’,’j’,’bl’ black and blue INSTR(char,substr[,pos]) 查找子串位置 instr(‘worldwide’,’d’) 5 SUBSTR(char,pos,len) 取子字符串 substr(‘abcdefg’,3,2) cd CONCAT(char1,char2) 连接字符串 concat(‘Hello’,’world’) Helloworld 数值函数 函数 功能 示例 结果 ABS(n) 取绝对值 abs(-15) 15 CEIL() 向上取整 ceil(44.778) 45 SIN(n) 正弦 sin(1.571) 0.999999979 COS(n) 余弦 cos(0) 1 SIGN(n) 取符号 sign(-30) -1 FLOOR(n) 向下取整 floor(100.2) 100 POWER(m,n) m的n次幂 pow(4.2) 16 MOD(m,n) 取余数 mod(10,3) 1 ROUND(m,n) 四舍五入 round(100.256,2) 100.26 TRUNC(m,n) 截断 trunc(100.256,2) 100.25 SQRT(n) 平方根 sqrt(4) 2 日期函数 函数 功能 示例 结果 MONTHS_BETWEEN 返回两个日期间的月份 months_between (‘04-11月-2005’,’11-1月-01’) 57.7741935 ADD_MONTHS 返回把月份数加到日期上的新日期 add_months(‘06-2月-03’,1)add_months(‘06-2月-03’,-1) 06-3月-200306-1月-2003 NEXT_DAY 返回指定日期后的星期对应的新日期 next_day(‘06-2月-2003’,’星期一’) 10-2月-2003 LAST_DAY 返回指定日期所在月的最后一天 last_day(‘06-2月-2003’) 28-2月-2003 ROUND 按指定格式对日期进行四舍五入 round(to_date(‘13-2月-2003’),’YEAR’) round(to_date(‘13-2月-2003’),’MONTH’)round(to_date(‘13-2月-2003’),’DAY’) 01-1月-200301-2月-200316-2月-2003 TRUNC 对日期按指定方式进行截断 trunc(to_date(‘06-2月-2003’),’YEAR’)trunc(to_date(‘06-2月-2003’),’MONTH’)trunc(to_date(‘06-2月-2003’),’DAY’) 01-1月-200301-2月-200302-2月-2003 *多行函数 函数 功能 MAX 返回该字段的最大值 MIN 返回该字段的最小值 SUM 返回该字段的和 AVG 返回该字段的平均值 COUNT count(*) 返回表的记录数count(字段名) 返回非空值的数量count(distinct 字段名) 去除重复后的字段值的数量 转化函数 to_number(数值类型的字符)：将字符转换为数值 to_char(数值或者是日期)：将数值或者日期转换为字符 to_date(日期格式的字符)：将字符转换为日期 数值和字符的互相转换字符转换为数字1select to_number('123')+2 from dual 数字转换字符指定显示格式 9表示位置占位，例如999,999,999会将数字按照三个一组使用逗号隔开 L表示人民币符号，$表示美元符号 0可以进行占位分组，但是如果真实数据位数不足，会使用0进行补位 123select to_char(123456789,'L999,999,999') from dualselect to_char(123456789,'$999,999,999') from dualselect to_char(123456789,'000,000,000,000.000') from dual 数值和字符之间的转换可以隐式转换。to_number可以省略不写 123--查询工资大于2000的员工信息select * from emp where sal&gt;'2000';select * from emp where sal&gt;to_number('2000'); 日期和字符的互相转换一般使用时机：新增数据使用to_date(),查询数据使用to_char() 字符转换为日期使用to_date(‘要转换的字符’,日期格式)函数将字符转换为日期 注意1：字符必须符合日期格式 注意2:oralce默认的转换格式为日月年，例如’01-1月-2018’ oracle认为是一个日期 常用日期格式：yyyy-mm-dd、yyyy/mm/dd 1234--查询员工入职日期在82年后的信息 select * from emp where hiredate &gt;to_date('1982-01-01','yyyy-mm-dd') select * from emp where hiredate &gt;to_date('1982/01/01','yyyy/mm/dd') select * from emp where to_char(hiredate,'yyyy-mm-dd') &gt;'1982-01-01' 日期转换为字符使用to_char(‘要转换的日期’,转换格式) 注意：如果不指名转换格式，则使用默认格式，日月年例如:’01-1月-81’ 常用转换格式：yyyy-mm-dd、yyyy/mm/dd、’yyyy”年”mm”月”dd”日” 1234select to_char(hiredate) from emp --使用默认格式将日期转换为字符select to_char(hiredate,'yyyy-mm-dd') from emp --使用指定格式 yyyy-mm-ddselect to_char(hiredate,'yyyy/mm/dd') from emp --使用指定格式 yyyy/mmm/ddselect to_char(hiredate,'yyyy&quot;年&quot;mm&quot;月&quot;dd&quot;日&quot;') from emp --使用指定格式 'yyyy&quot;年&quot;mm&quot;月&quot;dd&quot;日&quot;' 其他函数 nvl():nvl(字段名,值)如果字段值不为null返回字段值，否则返回设定的值 nvl2()：nvl2(字段名，处理1，处理2)如果字段值不为null执行处理1，否则执行处理2 decode()：decode(字段名，值1，处理1，值2，处理2，值3，处理3，…公共处理)如果字段的值与decode中的条件值相同则执行对象的处理，否则执行公共处理 1234567--查询员工的工资select ename,job,sal from emp--查询员工的薪资select ename,job,sal+nvl(comm,0),sal+comm,sal from empselect ename,job,nvl2(comm,sal+comm,sal) from emp--显示员工的职称select ename,job,decode(job,'MANAGER','经理','PRESIDENT','董事长','SALESMAN','销售','普通员工') from emp","link":"/2019/04/15/03.%E5%8D%95%E8%A1%8C&%E5%A4%9A%E8%A1%8C&%E8%BD%AC%E6%8D%A2&%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0/"},{"title":"02.单表查询","text":"查询表的所有数据select * from 表名 1select * from emp 查询表中指定字段的值 select 字段名1，字段名2，… from 表名 12select empno from empselect empno,ename from emp 给查询结果中的字段使用别名 在字段名后使用关键字 – 字段名 as “别名” 注意：as关键字可以省略不写，别名中没有特殊字符双引号也可以省略不写 1select empno 员工编号,ename &quot;员工姓名&quot;,job as 工作, mgr as &quot;领导编号&quot; from emp 连接符：拼接两个字段 “||”为sql语句的连接符，使用在select和from之间 字符连接格式为 —– 字段名||’字符’||字段名 注意：一个拼接好的连接在结果集中是作为一个新的字段显示，可以使用别名优化字段显示 1select empno||'的姓名是'||ename as &quot;信息&quot;,job from emp 去除重复 select distinct 字段名，字段名，… from 表名 注意：去除重复的规则是按照行去进行去除的，多行数据完全一样取其一 1select distinct job,mgr from emp 排序单字段排序 select * from 表名 order by 字段名 asc 升序排序 asc可以省略不写 1select * from emp order by empno desc select * from 表名 order by 字段名 desc 降序排序 1select empno,ename,job from emp order by ename asc 多字段排序 select * from 表名 order by 字段名1，字段名2… 先按照字段1排序，如果字段1的值相同，则按照字段2继续排序，以此类推 1select * from emp order by empno,ename 字段的逻辑运算 select关键字和from关键字之间的字段可以直接进行四则运算 字段与字段之间也可以直接进行运算 注意：字段值为数值类型 12select * from empselect empno,ename,job,sal*2+1000,sal+comm from emp 使用where子句查询筛选 select 字段名，字段名，…from 表名 where 筛选条件 单筛选条件 使用运算符进行筛选 =,,=,&lt;,&lt;=,&lt;单个条件中（&lt;为不等于符号） 注意：如果条件中的值为字符，必须使用单引号括起来 12345678--查询所有员工的工资信息select empno,ename,sal+comm as 薪资 from emp--查询SMITH的个人信息，逻辑运算符=select * from emp where ename='SMITH'--查询工资大于1000的员工信息,逻辑符select * from emp where sal'1000'--查询工资不等于3000的员工信息，逻辑符&lt;select * from emp where sal&lt;'3000' 多条件筛选 where子句关键字：and,or,like,is null,is not null, in ,between and 使用and关键字，多条件同时成立的筛选使用and关键字进行条件连接使用between，and关键字进行条件连接，包含两头的数据 123--查询工资在2000-3000之间的员工信息 select * from emp where sal='2000' and sal&lt;'3000' select * from emp where sal between '2000' and '3000' 使用or关键字，进行或条件的筛选使用in关键字，也可以进行或筛选，但是in中的内容只能为一个字段的值 123--查询工作为SALESMAN,ANALYST,MANAGER的员工信息 select * from emp where job='SALESMAN' or job='ANALYST' or job='MANAGER' select * from emp where job in ('SALESMAN','ANALYST','MANAGER') select * from 表名 where 字段名 like ‘%字符%’ 查询包含指定字符的数据select * from 表名 where 字段名 like ‘字符%’ 查询以指定字符开头的数据select * from 表名 where 字段名 like ‘%字符’ 查询以指定字符结尾的数据select * from 表名 where 字段名 like ‘_字符%’ 查询指定位置为指定字符的数据 12345678910--查询姓名中包含S的，以S开头的，以S结尾的，第二个字符为A的。(模糊查询) --%号表任意多个的任意字符 --select * from 表名 where 字段名 like '%字符%' 查询包含指定字符的数据 select * from emp where ename like '%S%' --包含S的 --select * from 表名 where 字段名 like '字符%' 查询以指定字符开头的数据 select * from emp where ename like 'S%' --以S开头 --select * from 表名 where 字段名 like '%字符' 查询以指定字符结尾的数据 select * from emp where ename like '%S' --以S结尾 --select * from 表名 where 字段名 like '_字符%' 查询指定位置为指定字符的数据 select * from emp where ename like '_A%' --第二个字符为A的 select * from 表名 where 字段名 like ‘%字符2字符1%’ escape’字符2’escape将指定的字符变为转义字符，转义字符可以将特殊字符转为普通字符 1234--select * from 表名 where 字段名 like '%字符2字符1%' escape'字符2' --escape将指定的字符变为转义字符 --转义字符可以将特殊字符转为普通字符 select * from emp where ename like '%/_%' escape '/' 字段值为null 1234--查询有津贴的员工信息--select * from 表名 where 字段名 is null 字段值为null--select * from 表名 where 字段名 is not null 字段值不为null select * from emp where comm is not null and comm0","link":"/2019/04/06/02.%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2/"},{"title":"07.SQL92&amp;SQL99实现三表联合查询","text":"SQL92实现特点：易于书写，难于阅读(SQL92的SQL语句结构不清晰) 用法123456select 内容（别名，连接符，去除重复，函数，逻辑运算）from 表名1，表名2，表名3...where 条件（连接条件，普通筛选条件，where子句关键词）group by 分组字段having 多行函数筛选order by 排序字段 实例12345678--查询员工信息及部门名称及所在城市名称select e.*,d.dname,c.cname,c.cdesc from emp e,dept d,city c where e.deptno=d.deptno and d.loc=c.cid--查询员工信息及部门名称及所在城市名称并且员工的工作大于2000或者有奖金select e.*,d.dname,c.cname,c.cdescfrom emp e,dept d,city cwhere e.deptno=d.deptno and d.loc=c.cid and (e.sal&gt;2000 or comm is not null)order by e.sal SQL99实现特点：虽然书写较复杂，但易于阅读 使用123456789select 内容 from 表名1inner join 表名2on 连接条件inner join 表名3on 连接条件where 普通筛选条件group by 分组字段having 多行函数筛选order by 排序字段 实例12345678--查询员工信息及部门名称及所在城市名称并且员工的工作大于2000或者有奖金select * from emp einner join dept don e.deptno=d.deptnoinner join city con d.loc=c.cidwhere e.sal&gt;2000 or e.comm is not nullorder by e.sal","link":"/2019/04/16/07.SQL92&SQL99%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A1%A8%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2/"},{"title":"04.分组查询&amp;分组筛选","text":"分组查询关键字：group by 分组字段名 分组字段名，分组字段名，… 注意1：使用了分组后，在select语句中只允许出现分组字段和多行函数 注意2：如果是多字段分组，则先按照第一字段分组，再按照第二字段再次分组，以此类推 注意3：在where子句中不允许出现多行函数 分组筛选关键字：having作用:针对进行分组后的数据进行筛选，运行使用多行函数 where和having的比较 where子句不允许出现多行函数，having子句允许出现多行函数 where子句和having都可以使用普通字段直接进行筛选，但where的效率高于having where执行顺序：from–&gt;where–&gt;group by–&gt;select–&gt;order by having执行顺序:from–&gt;group by–&gt;select–&gt;having–&gt;order by 结论：在分组语句中，使用where进行字段级别的筛选，使用having进行多行函数的筛选 123456789101112131415161718192021--查询最高工资和员工数select max(sal),count(*) from emp--查询不同部门的最高工资select * from emp order by deptno asc,sal descselect deptno,max(sal) from emp group by deptno--查询不同工作岗位的员工数select job,count(*) from emp group by job--查询不同部门的不同的工作岗位的人数select deptno,job,count(*) from emp group by deptno,job order by deptno asc,count(*) desc--查询不同部门的不同工作岗位的并且人数大于1的信息select deptno,job,count(*) from emp group by deptno,job having count(*)&gt;1--查询部门号大于10的不同部门的不同工作岗位的人数 --使用having关键字 select deptno,job,count(*) from emp group by deptno,job having deptno&gt;10 order by deptno --使用where关键字 select deptno,job,count(*) from emp where deptno&gt;10 group by deptno,job order by deptno","link":"/2019/04/16/04.%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2&%E5%88%86%E7%BB%84%E7%AD%9B%E9%80%89/"},{"title":"06.SQL92&amp;SQL99多表联合查询","text":"当需要获取的数据分布在多张表中时，考虑联合查询 SQL92联合查询笛卡尔积定义：将多个表的数据一一对应，所得结果为笛卡尔积，结果数量等于各表数量乘积 1select * from emp,dept 等值连接定义：先做表的笛卡尔积，然后筛选，筛选条件为等值筛选注意：筛选所用字段值必须相同，字段名可以不同 1select * from emp,dept where emp.deptno=dept.deptno 不等值连接定义：先做表的笛卡尔积，然后筛选，筛选条件为非等值筛选 1select * from emp e,salgrade s where e.sal&gt;=s.losal and e.sal&lt;=s.hisal 自连接定义：同一张表做笛卡尔积，然后筛选外连接 左外连接：加在右边，显示左边对应字段没有值的数据 右外连接：加在左边，显示右边对应字段没有值的数据 12345678910111213141516171819--查询员工姓名、工作、薪资、部门名称（等值连接） --可以直接在select子句中使用字段获取数据，但效率较低，建议字段名前应加上表名 --注意：如果是公共字段，那么必须声明表名 select ename,job,sal,dname from emp,dept where emp.deptno=dept.deptno select emp.ename,emp.job,emp.sal,dept.dname from emp,dept where emp.deptno=dept.deptno order by dept.dname --注意：表名太长时，我们可以对其使用别名 select e.ename,e.job,e.sal,d.dname from emp as e,dept as d where e.deptno=d.deptno order by d.dname--查询员工姓名、工作、工资、工资等级（非等值连接）select e.ename,e.job,e.sal,s.grade from emp e,salgrade s where e.sal&gt;=s.losal and e.sal&lt;=s.hisal--查询员工姓名、工作、薪资及上级领导姓名（自连接）select e1.ename,e1.job,e1.sal,e2.ename from emp e1,emp e2 where e1.mgr=e2.empno--查询员工姓名、工作、薪资及上级领导姓名及没有部门的员工信息（左外连接）select * from emp e,dept d where e.deptno=d.deptno(+)--查询员工姓名、工作、薪资及上级领导姓名及没有员工的部门信息（右外连接）select * from emp e,dept d where e.deptno(+)=d.deptno SQL99多表联合查询注意： 可以给表添加别名 如果使用on或者using关键字对结果进行筛选，必须使用inner join作为表与表的连接，其中inner可以省略不写 外连接的outer关键字可以省略不写 依然可以使用分组group by、排序order by等 笛卡尔积select 内容 from 表名 cross join 表名 1select * from emp cross join dept 自然连接使用：select 内容 from 表名 natural join 表名特点：底层先笛卡尔积，然后按照同名同值字段自动进行筛选 1select * from emp natural join dept 问题： 无法按照部分字段进行结果筛选 无法按照字段名不同，但字段值相同进行等值筛选 解决1：使用 using 关键字作用：使用指定的字段对联合查询的结果进行等值筛选注意：指明的字段必须是两表的同名同值字段使用：select 内容 from 表名 inner join 表名 using(字段名，字段名，…) 1select * from emp inner join dept using(deptno) 解决2：使用 on 关键字使用：select 内容 from 表名 inner join 表名 on 连接条件 where 普通筛选条件注意：普通筛选条件使用where进行筛选，不要使用on。好处：SQL语句的阅读性增强 1select * from emp inner join dept on emp.deptno=dept.deptno 外连接左外连接:select 内容 from 表名 left outer join 表名 on 连接条件 12--查询员工姓名、工作、薪资、部门名称及没有部门的员工信息select * from emp e left join dept d on e.deptno=d.deptno 右外连接:select 内容 from 表名 rigth outer join 表名 on 连接条件 12--查询员工姓名、工作、薪资、部门名称及没有员工的部门信息select * from emp e right join dept d on e.deptno=d.deptno 全外连接:select 内容 from 表名 full outer join 表名 on 连接条件 12--查询员工姓名、工作、薪资、部门名称、没有部门的员工信息、没有员工的部门信息select * from emp e full join dept d on e.deptno=d.deptno 自连接12--查询员工及其上级领导姓名select * from emp e1 inner join emp e2 on e1.mgr=e2.empno","link":"/2019/04/16/06.SQL92&SQL99%E5%A4%9A%E8%A1%A8%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2/"},{"title":"08.子查询","text":"使用时机：当查询的筛选条件不明确时，考虑使用子查询 单行子查询使用时机：筛选条件不明确需要执行一次查询，并且查询结果一个字段并值只有一个注意：where子句中允许出现查询语句，该查询语句称为子查询使用：select 内容 from 表名 where 字段名 比较运算符 子查询语句 123456789101112--查询所有比雇员“CLARK”工资高的员工信息select * from emp where sal&gt;(select sal from emp where ename ='CLARK')--查询工资高于平均工资的员工的名字和工资select ename,sal from emp where sal&gt;(select avg(sal) from emp )--查询和soctt属于同一部门且工资比他低的员工资料select * from emp where deptno=(select deptno from emp where ename='SCOTT') and sal&lt;(select sal from emp where ename='SCOTT')--查询工资最高的员工资料select * from emp where sal=(select max(sal) from emp)--查询职务和scott相同，雇佣时间早的员工信息select * from emp where job=(select job from emp where ename='SCOTT') and hiredate &lt;(select hiredate from emp where ename='SCOTT')--查询工资比scott高或者雇佣时间早的员工编号和名字select empno,ename from emp where job=(select job from emp where ename='SCOTT') or hiredate &lt;(select hiredate from emp where ename='SCOTT') 多行子查询使用:子查询的结果只有一个字段但是字段有n个值，考虑使用多行子查询，其实就是使用如下关键字 any 任意select 内容 from 表名 where 字段名 比较运算符 any 子查询语句 all 所有select 内容 from 表名 where 字段名 比较运算符 all 子查询语句 in 表示任意存在,相当于 = anyselect 内容 from 表名 where 字段名 in 子查询语句select 内容 from 表名 where 字段名 not in 子查询语句123456789--查询工资高于任意一个CLERK的所有员工信息select * from emp where sal&gt; any (select sal from emp where job='CLERK')--查询工资高于所有SALESMAN的员工信息select * from emp where sal&gt; all (select sal from emp where job='SALESMAN')--查询部门20中同部门10的雇员工作一样的雇员信息select job from emp where deptno=10select *from emp where (job='MANAGER' or job='PRESIDENT' or job='CLERK') and deptno=20select * from emp where job in (select job from emp where deptno=10) and deptno=20select * from emp where job = any (select job from emp where deptno=10) and deptno=20","link":"/2019/11/12/08.%E5%AD%90%E6%9F%A5%E8%AF%A2/"},{"title":"10.二维表管理(创建&amp;约束&amp;字段)","text":"简单二维表的创建使用：create table 表名(字段名 类型，字段名 类型，….); 数据类型： number类型 数值类型 整数类型number(a)：总长度为a 浮点数类型number(a,b)：总长度为a，小数位长度为b，小数位可以不写。 字符类型 varchar2(ln)ln表示字符的最大长度，实际存储内存长度是根据字符大小来分配，但是最大不能超过ln特点：动态分配存储空间，节省空间 char(ln)不管字符数据长度是多大，直接开辟ln大小的空间存储数据特点：存储效率高于varchar2 date类型 123456789101112create table student( sno number(10), sname varchar2(100), sage number(3), ssex char(4), sfav varchar2(500), sbirth date)--添加测试数据insert into student values(1,'柳岩',18,'女','拍电影'，'01-1月-1985');insert into student values(2,'古力娜扎',20,'女','拍电影'，to_date('1990-01-01','yyyy-mm-dd'));select * from student 二维表的约束主键特点：非空唯一 使用： 直接在创建表的字段后使用 primary key 在创建表的语句最后面使用 constraint pk_表名_字段名 primary key(字段名) 在创建表后使用 alter table 表名 add constraint 主键的约束名(一般写成pk_表名_字段名) primary key(字段名) 删除主键约束 alter table 表名 drop constraint 主键的约束名 非空约束使用： 直接在创建表的字段后使用 not null 在创建表的语句最后面使用 constraint ck_表名_字段名 check(字段名 is not null) 在创建表后使用 alter table 表名 add constraint 非空约束名(一般写成ck_表名_字段名) check(字段名 is not null) 删除非空约束 alter table 表名 drop constraint 非空约束名 检查约束使用： 直接在创建表的字段后使用 check(条件) 在创建表的语句最后面使用 constraint ck_表名_字段名 check(字段名 is not null) 在创建表后使用 alter table 表名 add constraint 检查约束名(一般写成ck_表名_字段名) check(条件) 删除检查约束 alter table 表名 drop constraint 检查约束名 唯一约束使用： 直接在创建表的字段后使用 unique 在创建表的语句最后面使用 constraint un_表名_字段名 unique(字段名) 在创建表后使用 alter table 表名 add constraint 唯一约束名(一般写成un_表名_字段名) unique(字段名) 删除唯一约束 alter table 表名 drop constraint 唯一约束名 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152create table student( sno number(10),--primary key sname varchar2(100),--not null sage number(3),--check(sage&lt;150 and sage&gt;0) ssex char(4),--check(ssex='男' or ssex='女') sfav varchar2(500), sbirth date, sqq varchar2(30)--unique --为字段sno添加主键约束 --,constraint pk_student_sno primary key(sno) --为字段sname添加非空约束 --,constraint ck_student_sname check(sname is not null) --为字段sage添加检查约束 --,constraint ck_student_sage check(sage&lt;150 and sage&gt;0) --为字段ssex添加检查约束 --,constraint ck_student_ssex check(ssex='男' or ssex='女') --为字段sqq添加唯一约束 --,constraint un_student_sqq unique(sqq));--添加主键约束alter table student add constraint pk_student_sno primary key(sno);--删除主键约束alter table student drop constraint pk_student_sno;--添加非空约束alter table student add constraint ck_student_sname check(sname is not null);--删除非空约束alter table student drop constraint ck_student_sname;--添加检查约束限制年龄为正常范围alter table student add constraint ck_student_sage check(sage&lt;150 and sage&gt;0);--删除限制年龄为正常范围的检查约束alter table student drop constraint ck_student_sage;--添加检查约束校验性别alter table student add constraint ck_student_ssex check(ssex='男' or ssex='女');--删除校验性别的检查约束alter table student drop constraint ck_student_ssex;--添加唯一约束alter table student add constraint un_student_sqq unique(sqq);--删除唯一约束alter table student drop constraint un_student_sqq;select * from student;drop table student; 外键约束作用：当在子表中插入的数据在父表中不存在的时候，会自动报错 概念：当一张表的某个字段的值需要依赖另外一张表的某个字段的值时，使用外键约束，其中主动依赖的表称为子表，被依赖的表称为父表，外键加在子表中 使用： 在子表创建的时候直接在字段后使用 references 父表名(字段名) 在子表创建的时候在语句最后使用 constraint 外键约束名(一般为fk_字表名_字段名) foreign key(字段名) references 父表名(字段名) 在子表创建后使用 alter table 子表名 add constraint 外键约束名(一般为fk_字表名_字段名) foreign key(字段名) references 父表名(字段名) 删除外键约束 alter table 子表名 drop constraint 外键约束名 外键选取：一般选取父表的主键作为子表的外键 外键的缺点：无法直接删除父表数据解决方案： 级联删除：在添加外键约束时，使用关键字 on delete cascade 当删除父表数据时，自动删除子表相关的所有数据缺点：无法保留子表的历史数据 在添加外键约束时，使用关键字 on delete set null 删除父表数据时，将子表中的依赖字段的值设置为null 注意：子表依赖字段不能添加非空约束 123456789101112131415161718192021222324252627282930313233343536373839404142--创建学生表create table student( sno number(10) primary key, sname varchar2(100) not null, sage number(3) check(sage&lt;150 and sage&gt;0), ssex char(4) check(ssex='男' or ssex='女'), sfav varchar2(500), sqq varchar2(30) unique, cno number(10) --references clazz(cno) --添加外键约束 --,constraint fk_student_cno foreign key(cno) references clazz(cno));--添加外键约束alter table student add constraint fk_student_cno foreign key(cno) references clazz(cno);--删除外键约束alter table student drop constraint fk_student_cno;--添加测试数据insert into student values(1,'张三',18,'男','唱歌','657889900',1);insert into student values(2,'李四',18,'男','跳舞','657889901',1);insert into student values(3,'王麻子',18,'男','BBox','657889902',2);insert into student values(4,'廖壳子',18,'男','篮球','657889903',2);drop table student;--创建班级表create table clazz( cno number(10) primary key, cname varchar2(100) not null, cdesc varchar2(300));--添加测试数据insert into clazz values(1,'java高级班','666');insert into clazz values(2,'python高级班','233');--查询学生及其班级信息select * from student sinner join clazz con s.cno=c.cno 二维表的维护添加新的字段alter table 表名 add 字段名 类型 1alter table student add sphone number(11);--在学生表中添加新字段sphone 修改原有字段 修改字段类型alter table 表名 modify 字段名 新的类型 1alter table student modify sphone varchar2(11); 修改字段名alter table 表名 rename column 字段名 to 新的字段名; 1alter table student rename column sphone to phone; 删除字段alter table 表名 drop column 字段名 1alter table student drop column phone; 修改表名alter table 原有表名 rename to 新的表名 12alter table student rename to student2;alter table student2 rename to student; 删除表drop table 表名 1drop table student;","link":"/2019/11/12/10.%E4%BA%8C%E7%BB%B4%E8%A1%A8%E7%AE%A1%E7%90%86(%E5%88%9B%E5%BB%BA&%E7%BA%A6%E6%9D%9F&%E5%AD%97%E6%AE%B5)/"},{"title":"05.增删改&amp;数据备份","text":"主键：在一张表中，某个字段的值是非空且唯一的，可以将此字段作为主键主键的作用：唯一的标识一条数据 增加数据insert into 表名（字段名，字段名，字段…）values(值1，值2，值…) 注意1：主键必须给值，允许为空的字段可以不给值 注意2：插入语句表名后跟的字段名为要赋值的字段，值和字段必须一一对应 注意3：如果是全字段插入，可以省略字段名 1234567--在部门表中新增一个部门信息，信息内容为 编号：50，名称：LOL学院，地址：重庆insert into dept(deptno,dname,loc)values(50,'LOL学院','重庆')insert into dept values(50,'LOL学院','重庆')insert into dept(deptno,dname,loc)values(60,'LOL学院','重庆')select * from dept--在部门中新增一条数据，只有部门编号和名称，没有地址insert into dept(deptno,dname)values(70,'吃鸡学院') 删除数据删除表中的所有记录：delete from 表名truncate table 表名 删除表中所有的记录，但是效率高于delete删除表中符合条件的数据：delete from 表名 where 条件 12345delete from deptdelete from dept where deptno=50select * from depttruncate table dept 更新数据update 表名 set 字段名=新的值，字段名=新的值…(将字段的值全部改为新的值)update 表名 set 字段名=新的值，字段名=新的值… where 条件(将符合条件的字段的值改为新的值) 12update dept set dname='java学院',loc='上海' where deptno=70select * from dept 数据的备份注意：只会备份表的结构和表的数据，约束不会备份表级别备份 全部备份该表：create table 新的表名 as select * from 备份表名 部分备份：create table 新的表名 as select 字段名，字段名，… from 备份表名 12create table deptBak as select * from dept --全部备份create table depBak2 al select deptno,dname from dept --部分备份 数据整体插入insert into 表名 select * from 表名注意：查询语句的结果的各字段必须和插入表名的各字段一一对应 12insert into deptBak select * from deptselect * from deptBak","link":"/2019/04/16/05.%E5%A2%9E%E5%88%A0%E6%94%B9&%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"},{"title":"AOP之异常通知与环绕通知","text":"异常通知异常通知：只有当切点报异常才能触发异常通知 AspectJ方式实现 新建类,在类写任意名称的方法12345public class MyThrowAdvice{ public void myexception(Exception e1){ System.out.println(&quot;执行异常通知&quot;+e1.getMessage()); }} 在 spring 配置文件中配置 1 &lt;aop:aspect&gt;的 ref 属性表示:方法在哪个类中 2 &lt;aop: xxxx/&gt;表示什么通知 3 method: 当触发这个通知时,调用哪个方法 4 throwing: 异常对象名，必须和通知中方法参数名相同(可以不在通知中声明异常对象)12345678&lt;bean id=&quot;mythrow&quot; class=&quot;top.ljc.advice.MyThrowAdvice&quot;&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;aop:aspect ref=&quot;mythrow&quot;&gt; &lt;aop:pointcut expression=&quot;execution(*top.ljc.test.Demo.demo1())&quot; id=&quot;mypoint&quot;/&gt; &lt;aop:after-throwing method=&quot;myexception&quot; pointcut-ref=&quot;mypoint&quot; throwing=&quot;e1&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;bean id=&quot;demo&quot; class=&quot;top.ljc.test.Demo&quot;&gt;&lt;/bean&gt; Schema-based方式实现 新建一个类实现 throwsAdvice 接口 1 必须自己写方法，且必须叫afterThrowing 2 有两种参数方式，必须是1个或4个 3 异常类型要与切点报的异常类型一致12345678public class MyThrow implements ThrowsAdvice{//public void afterThrowing(Method m, Object[] args,Object target, Exception ex) {// System.out.println(&quot;执行异常通知&quot;);//} public void afterThrowing(Exception ex) throws Throwable { System.out.println(&quot;执行异常通过-schema-base 方式&quot;); }} 在 ApplicationContext.xml 配置123456&lt;bean id=&quot;mythrow&quot; class=&quot;top.ljc.advice.MyThrow&quot;&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(*top.ljc.test.Demo.demo1())&quot; id=&quot;mypoint&quot;/&gt; &lt;aop:advisor advice-ref=&quot;mythrow&quot; pointcut-ref=&quot;mypoint&quot; /&gt;&lt;/aop:config&gt;&lt;bean id=&quot;demo&quot; class=&quot;top.ljc.test.Demo&quot;&gt;&lt;/bean&gt; 环绕通知(Schema-based方式)把前置通知和后置通知都写到一个通知中,组成了环绕通知 新建一个类实现 MethodInterceptor123456789public class MyArround implements MethodInterceptor {@Override public Object invoke(MethodInvocation arg0) throws Throwable { System.out.println(&quot;环绕-前置&quot;); Object result = arg0.proceed();//放行,调用切点方式 System.out.println(&quot;环绕-后置&quot;); return result; }} 配置 applicationContext.xml123456&lt;bean id=&quot;myarround&quot; class=&quot;top.ljc.advice.MyArround&quot;&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(*top.ljc.test.Demo.demo1())&quot; id=&quot;mypoint&quot;/&gt; &lt;aop:advisor advice-ref=&quot;myarround&quot; pointcut-ref=&quot;mypoint&quot; /&gt;&lt;/aop:config&gt;&lt;bean id=&quot;demo&quot; class=&quot;top.ljc.test.Demo&quot;&gt;&lt;/bean&gt;","link":"/2020/02/27/AOP%E4%B9%8B%E5%BC%82%E5%B8%B8%E9%80%9A%E7%9F%A5%E4%B8%8E%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5/"},{"title":"11.Oracle序列&amp;视图&amp;索引","text":"Oracle的序列学习创建序列使用：create sequence 序列名 特点： 默认开始是没有值的，也就是指针指在了没有值的位置 序列名.nextval每次执行都会自增一次，默认步长为1 序列名.currval查看当前序列的，开始是没有的 作用：作为主键使用，动态的获取主键的值，新增数据时避免了主键冲突，使用的是序列名.nextval作为主键 注意：主键是非空唯一就可以，不需要主键的值是连续的值 12345678910111213141516171819202122--创建默认序列 create sequence cc; --创建序列cc select cc.currval from dual; --查看序列当前值 select cc.nextval from dual; --查看序列自增后的值--创建自定义序列 create sequence aa start with 5 --设置序列从5开始 increment by 2; --设置序列步长为2 select aa.currval from dual; select aa.nextval from dual; --创建测试表 create table teacher( tid number(10) primary key, tname varchar2(100) not null ); insert into teacher values(cc.nextval,'张三'); insert into teacher values(cc.nextval,'李四'); insert into teacher values(cc.nextval,'王五'); insert into teacher values(cc.nextval,'赵六'); select * from teacher; drop table teacher; 删除序列drop sequence 序列名 12drop sequence aa;drop sequence cc; 索引作用：提升查询效率 使用： 创建索引：create index 索引名 on 表名(字段名) 删除索引：drop index 索引名 特点：显示的创建，隐式的执行 注意：Oracle或自动给表的主键创建索引 1234create index index_teacher_tname on teacher(tname); --创建索引drop index index_teacher_tname; --删除索引select * from teacher where tid=8;select * from teacher where tname='张三'; 视图使用： 创建视图：create view 视图名 as select 对外提供的内容 from 真实表名 删除视图：drop view 视图名 视图特点： 保护真实表，隐藏重要的字段的数据，保护数据 在视图中的操作会映射执行到真实表中 可以手动开启只读模式，使用关键字 with read only 注意：视图的创建必须拥有dba权限 12345create view stu as select sno,sname,sage from student;create view stu2 as select sno,sname,sage from student with read only;select * from stu;update stu set sname='maskwolf' where sno=1;select * from student;","link":"/2019/11/12/11.%E5%BA%8F%E5%88%97&%E8%A7%86%E5%9B%BE&%E7%B4%A2%E5%BC%95/"},{"title":"09.Oracle账户管理","text":"权限：具备某类事物的操作的能力，此能力称为权限。角色：一系列权限的集合 oracle自带账户： system 管理账户特点：具备大部分oracle的操作权限，主要用来管理普通账户及oralce的数据使用人：oracle数据维护工作人员 sys 超级管理员账户特点：具备system的所有权限，同时又具备其他的权限使用人：oracle攻城狮 创建账户使用system账户，并使用dba身份，登录oracle管理系统 12--创建用户 create user liaojincan identified by liaojincan; 维护账户 赋予权限 — grant 权限或者角色名 to 用户名 1234grant connect to bjsxt;--给用户赋予登录权限grant resource to bjsxt;--给用户资源操作权限grant dba to bjsxt;--给用户赋予dba权限select * from scott.emp--查看其它用户的表 使用用户名.表名 删除权限 — revoke 权限或者角色名 from 用户名 1revoke dba from bjsxt; 删除账户drop user 用户名 1drop user maskwolf;","link":"/2019/11/12/09.Oracle%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86/"},{"title":"Ajax技术","text":"Ajax相关概念及应用场景定义：AJAX全称为“Asynchronous JavaScript and XML”（异步JavaScript和XML），是一种创建交互式网页应用的网页开发技术，本质上是一个浏览器端的技术 所涉及技术： 基于web标准（standards-based presentation）XHTML+CSS的表示 使用 DOM（Document Object Model）进行动态显示及交互 使用 XML 和 XSLT 进行数据交换及相关操作 使用 XMLHttpRequest 进行异步数据查询、检索 使用 JavaScript 将所有的东西绑定在一起 应用场景：在保留原有页面内容的情况下，显示新的响应内容 Ajax的使用创建ajax引擎对象123456var ajax;if(window.XMLHttpRequest){//火狐 ajax=new XMLHttpRequest();}else if(window.ActiveXObject){//IE ajax=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);} 复写onreadystatement函数 readyState值 含义 0 表示XMLHttpRequest已建立，但还未初始化，这时尚未调用open方法 1 表示open方法已经调用，但未调用send方法（已创建，未发送） 2 表示send方法已经调用，其他数据未知 3 表示请求已经成功发送，正在接受数据 4 表示数据已经成功接收 http状态码 含义 200 资源获取成功 404 请求资源未找到 500 服务器内部错误 示例： 123456789ajax.onreadystatechange=function(){ //Ajax状态码为4时表示成功接收 if(ajax.readyState == 4){ //响应状态码为200上时表示获取资源成功 if(ajax.status == 200){ //获取数据并处理数据 } }} 发送请求get请求：请求实体用?与URL隔开，以键值对的形式拼接在URL后面 12ajax.open(&quot;get&quot;,&quot;url&quot;);ajax.send(null); post请求：有单独的请求实体 123ajax.open(&quot;post&quot;, &quot;url&quot;);ajax.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);ajax.send(&quot;name=张三&amp;pwd=123&quot;); ajax的异步和同步使用：ajax.open(method,urL,async) async：设置同步代码执行还是异步代码执行，true代表异步，false代表同步,默认是异步 异步：并行处理，程序向服务器发送一个请求后，在结果返回之前，程序还是可以执行其它操作（以前台界面为例，用户依然可以输入其它信息，并且和服务器进行其它交付） 同步：顺序处理，程序向服务器发送一个请求，在结果返回之前，程序要一直等待结果返回才可以执行下一步操作","link":"/2019/11/21/Ajax%E6%8A%80%E6%9C%AF/"},{"title":"HTTP与HTTPS","text":"HTTP (超文本传输协议)主要特点 支持客户/服务器模式 简单快速只需要传输请求方法和路径 灵活允许传输任意类型的对象 无连接每次连接只处理一个请求，即使长连接也是下层实现对上层透明 无状态对事物处理没有能力 当前多版本共存，主流版本是HTTP/1.1，相比较HTTP/1.0其引入了keepalive(长连接技术) HTTP的请求结构 HTTP的响应结构 HTTP请求/响应的步骤 客户端连接到Web服务器 发送HTTP请求 服务器接受请求并返回HTTP响应 释放TCP连接 客户端浏览器解析HTML内容 在浏览器地址栏键入URL，按下回车之后经历的流程 DNS解析逐层查询DNS缓存：浏览器缓存 → 系统缓存 → 路由器缓存 → 权限域名服务器缓存 → 顶级域名服务器缓存 → 根域名服务器缓存 TCP连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面，同时释放连接 HTTP状态码 1xx : 指示信息–表示请求已接收,继续处理 2xx : 成功–表示请求已被成功接收、理解、接受 3xx : 重定向–要完成请求必须进行更进一步的操作 4xx : 客户端错误–请求有语法错误或请求无法实现 5xx : 服务器端错误–服务器未能实现合法的请求 常见状态码 200 OK: 正常返回信息 400 Bad Request: 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized: 请求未经授权，此状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden: 服务器收到请求，但是拒绝提供服务 404 Not Found: 请求资源不存在，eg，输入了错误的URL 500 Internal Server Error: 服务器发生不可预期的错误 503 Server Unavailable: 服务器当前不能处理客户端的请求,一段时间后可能恢复正常 GET请求和POST请求的区别 HTTP报文层面GET将请求信息放在URL中，POST将请求信息放在报文体中 数据库层面GET请求符合幂等性 (对数据库一次操作和多次操作获得的结果是一致的) 和安全性 (对数据库的操作没有改变数据库中的数据) ，POST请求不符合 其他层面GET请求可以被缓存、被存储，而POST不行 Cookie和Session的区别 Cookie数据存放在客户的浏览器上, Session数据放在服务器上 Session相对于Cookie更安全 若考虑减轻服务器负担,应当使用Cookie HTTPS SSL(Security Sockets Layer，安全套接层) 为网络通信提供安全及数据完整性的一种安全协议 是操作系统对外的API，SSL3.0后更名为TLS 采用身份验证和数据加密保证网络通信的安全和数据的完整性 HTTPS数据的传输流程 浏览器将支持的加密算法信息发送给服务器 服务器选择一套浏览器支持的加密算法,以证书的形式回发浏览器 浏览器验证证书合法性,并结合证书公钥加密信息发送给服务器 服务器使用私钥解密信息,验证哈希,加密响应消息回发浏览器 浏览器解密响应消息,并对消息进行验真,之后进行加密交互数据 HTTP与HTTPS的区别 HTTPS需要到CA申请证书, HTTP不需要 HTTPS密文传输, HTTP明文传输 连接方式不同, HTTPS默认使用443端口, HTTP使用80端口 HTTPS=HTTP+加密+认证+完整性保护,较HTTP安全","link":"/2020/05/31/HTTP%E4%B8%8EHTTPS/"},{"title":"EL表达式","text":"作用：获取作用域对象中的数据 注意：EL表达式获取的是pageContext、request、session、application四个对象中的数据，找到就返回数据，反之什么都不做 语法：${表达式}、[] 使用EL表达式获取请求数据 ${param.键名}：返回键名所对应的请求数据的值 ${paramvalues.键名}：返回一个数组 使用EL表达式获取作用域数据作用域数据是通过setAttribute方法存储到作用域对象中的数据 使用：${键名}：返回键名所对应的值 注意： 如果存储的是普通字符串则直接返回 如果存储的是对象，则返回的是对象 获取对象中的数据 普通对象：${键名.属性名.属性名....} 集合对象 list集合：${键名[角标]} map集合：${键名.map集合存储的键名} 作用域查找顺序 默认查找顺序：pageConext---&gt;request---&gt;session---&gt;application 默认查找顺序每次查找都是从小到大进行查找，找到了则获取，不再继续向下查找了如果找到最后一个作用域也没有找到，便什么也不输出 指定作用域查找，在指定作用域找不到便不输出任何东西 ${pageScope.键名} ${requestScope.键名} ${sessionScope.键名} ${applicationScope.键名} 使用EL表达式进行运算 ${逻辑表达式}：&amp;&amp; || ! ${算术表达式}：+，-，*，/ ${关系表达式}：&gt;,&lt;,&gt;=,==,!=,% 三目运算：${表达式?执行1：执行2} 实例： 1${1+2}--${1*2}--${4/2}--${4-2}--${4%3}--${4==4}--${4&gt;2}--${sex==1?'男':'女'}--${1+'2'} 注意：+表示加法运算，不表示字符链接。使用EL表达式进行字符链接会报错 使用EL表达式进行空值判断${empty 键名}：判断键名对象的值是否存有数据 EL获取请求头数据和Cookie数据 请求头数据 ${header}：返回所有的请求头数据 ${header[&quot;键名&quot;]}：返回指定的键名的请求头数据 ${hedaerValues[&quot;键名&quot;]}：返回指定的键名(同键不同值)的值的数组 获取Cookie数据 ${cookie}：返回存储了所有的cookie对象的map集合 ${cookie.键名}：返回指定的cookie对象 ${cookie.键名.name}：返回指定的cookie对象存储的数据的键名 ${cookie.键名.value}：返回指定的cookie对象存储的数据的值","link":"/2019/11/28/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"JSTL标签库配置与使用","text":"在IDEA的Web项目中配置JSTL下载JSTL所需jar包官网下载地址 http://tomcat.apache.org/taglibs/standard/ 将所需的jar包导入工程中 为需要用到的标签库在项目中配置uri JSTL标签库的使用核心标签库在JSP页面声明引入核心标签库 1&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 基本标签 将数据输出给客户端&lt;c:out value=&quot;数据&quot; default=&quot;默认值&quot;&gt;&lt;/c:out&gt;数据可为常量值也可是EL表达式 存储数据到作用域对象中&lt;c:set var=&quot;键名&quot; value=&quot;数据&quot; scope=&quot;作用域对象&quot;&gt;&lt;/c:set&gt;scope可选值page、request、session、application 删除作用域中的指定键的数据&lt;c:remove var=&quot;键名&quot; scope=&quot;作用域对象&quot;/&gt; 注意： 如果在不指定作用域的情况使用该标签删除数据，会将四个作用域对象中的符合要求的数据全部删除 逻辑标签 进行逻辑判断，相当于java代码的单分支判断。 123&lt;c:if test=&quot;${表达式}&quot;&gt; 前端代码&lt;/c:if&gt; 注意： 逻辑判断标签需要依赖于EL的逻辑运算，也就是表达式中涉及到的数据必须从作用域中获取 进行多条件的逻辑判断，类似java中的多分支语句 123456&lt;c:choose&gt; &lt;c:when test=&quot;&quot;&gt;执行内容&lt;/c:when&gt; &lt;c:when test=&quot;&quot;&gt;执行内容&lt;/c:when&gt; ... &lt;c:otherwise&gt;执行内容&lt;/c:otherwise&gt;&lt;/c:choose&gt; 注意： 条件成立只会执行一次，都不成立则执行otherwise 循环标签 作用：循环内容进行处理 123&lt;c:forEach begin=&quot;1&quot; end=&quot;4&quot; step=&quot;2&quot;&gt; 循环体&lt;/c:forEach&gt; 使用: begin：声明循环开始位置 end：声明循环结束位置 step：设置步长 varStatus：声明变量记录每次循环的数据(角标，次数，是否是第一次循环，是否是最后一次循环) items:声明要遍历的对象。结合EL表达式获取对象 var:声明变量记录每次循环的结果。存储在作用域中，需要使用EL表达式获取 注意:数据存储在作用域中，需要使用EL表达式获取例如：${vs.index}--${vs.count}--${vs.first}--${vs.last}","link":"/2019/12/02/JSTL%E6%A0%87%E7%AD%BE%E5%BA%93%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"title":"12.Oracle分页查询","text":"作用：当一个表中的数据量特别大的时候，如果一次性全部显示给用户，则造成页面过于庞大，体验极差，使用分页查询可以解决这个问题 使用rownum关键字：oracle对外提供的自动给查询结果编号的关键字，与每行的数据没有关系 注意：rownum关键字只能做小于等于的判断，不能做大于的判断 123456789101112--查询员工信息的前五条数据 第一页数据select rownum,t.* from (select rownum r,e.* from emp e where rownum&lt;=5) t where r&gt;0--查询员工信息的6-10条数据 第二页数据select rownum,t.* from (select rownum r,e.* from emp e where rownum&lt;=10) t where r&gt;5--查询员工信息的11-15条数据 第三页数据select rownum,t.* from (select rownum r,e.* from emp e where rownum&lt;=15) t where r&gt;10 分页规律总结(每页显示m条数据，查询第n页数据)要分页的表既可以是真实的表，也可以是一个查询语句 123select rownum,t.* from (select rownum r,e.* from 要分页的表 e where rownum&lt;=n*m) t where r&gt;n*m-m 1234--分页查询员工信息按照工作排序select * from (select rownum r,t.* from (select * from emp order by sal) t where rownum&lt;=10) where r&gt;5","link":"/2019/11/12/12.Oracle%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/"},{"title":"Jsp基础知识一","text":"注释、局部/全局代码块、脚本段语句、动静态引入、转发标签 Jsp的三种注释 前端语言注释会被转译，也会被发送，但是不会被浏览器执行 java语言注释会被转译，但是不会被servlet执行 Jsp注释不会被转译 Jsp的page指令作用：配置jsp文件的转译相关的参数 使用：&lt;%@page 属性名=&quot;属性值&quot; 属性名=&quot;属性值&quot;...%&gt; language：声明jsp要被转译的语言 import:声明转译的java文件要导入的包，不同的包使用逗号隔开 pageEncoding:设置jsp文件的数据编码格式 contentType=”text/html; charset=utf-8” 设置jsp数据响应给浏览器时，浏览器的解析和编码格式 session:设置转译的servlet中是否开启session支持,默认开启，true表示开启，false表示关闭 errorPage:设置jsp运行错误跳转的页面 extends:设置jsp转译的java文件要继承的父类(包名+类名) Jsp的局部、全局代码块&amp;脚本段语句Jsp的局部代码块特点：局部代码块中声明的java代码会被原样转译到jsp对应的servlet文件的_JspService方法中,代码块中声明的变量都是局部变量 使用：&lt;% java代码 %&gt; 缺点：使用局部代码块在jsp中进行逻辑判断，书写麻烦，阅读困难 开发：servlet进行请求逻辑处理，使用jsp进行页面展现。 Jsp的全局代码块特点：声明的java代码作为全局代码转译到对应的servlet类中 使用：&lt;%! 全局代码 %&gt; 注意：全局代码块声明的代码，需要使用局部代码块调用 Jsp的脚本段语句特点：帮助我们快速的获取变量或者方法的返回值作为数据响应给浏览器 使用：&lt;%=变量名或者方法%&gt; 注意：不要在变量名或者方法后使用分号 位置：除jsp语法要求以外的任意位置 Jsp的静态引入和动态引入静态引入使用：&lt;%@include file=&quot;要引入的jsp文件的相对路径&quot; %&gt; 特点： 会将引入的jsp文件和当前jsp文件转译成一个java(Servlet)文件使用 在网页中也就显示了合并后的显示效果 注意： 静态引入的jsp文化不会单独转译成java(Servlet)文件 当前文件和静态引入的jsp文件中不能够使用java代码块声明同名变量 动态引入使用：&lt;jsp:include page=&quot;要引入的jsp文件的相对路径&quot;&gt;&lt;/jsp:include&gt; 特点： 会将引入的jsp文件单独转译，在当前文件转译好的java文件中调用引入的jsp文件的转译文件 在网页中显示合并后的显示效果 注意：动态引入允许文件中声明同名变量 jsp的转发标签使用：&lt;jsp:forward page=&quot;要转发的jsp文件的相对路径&quot;&gt;&lt;/jsp:forward&gt; 特点：一次请求，地址栏信息不改变 注意： 在转发标签的两个标签中间除了写&lt;jsp:param name=&quot;str&quot; value=&quot;aaa&quot; /&gt;子标签不会报错，其他任意字符都会报错 name属性为附带的数据的键名，value为附带的数据内容 会将数据以?的形式拼接在转发路径的后面","link":"/2019/11/20/Jsp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80/"},{"title":"Jsp基础知识二","text":"Jsp的九大内置对象&amp;四个作用域对象&amp;Jsp的路径 jsp的九大内置对象内置对象：jsp文件在转译成其对应的Servlet文件的时候自动生成的并声明的对象。我们在jsp页面中直接使用即可 注意：内置对象在jsp页面中使用，使用局部代码块或者脚本段语句来使用。不能够在全局代码块中使用 pageContext:页面上下文对象，封存了其他内置对象。封存了当前jsp的运行信息注意：每个Jsp文件单独拥有一个pageContext对象作用域：当前页面 request：封存当前请求数据的对象。由tomcat服务器创建。一次请求 session:此对象用来存储用户的不同请求的共享数据的。一次会话 application：也就是ServletContext对象，一个项目只有一个。存储用户共享数据的对象，以及完成其他操作。项目内 response:响应对象，用来响应请求处理结果给浏览器的对象。设置响应头，重定向 out:响应对象，Jsp内部使用。带有缓冲区的响应对象，效率高于response对象 page:代表当前Jsp的对象。相当于java中的this exception：异常对象。存储了当前运行的异常信息 注意：使用此对象需要在page指定中使用属性isErrorPage=”true”开启 config：也就是ServletConfig，主要是用来获取web.xml中的配置数据，完成一些初始化数据的读取 四个作用域对象 pageContext:当前页面.解决了在当前页面内的数据共享问题。获取其他内置对象 request:一次请求。一次请求的servlet的数据共享。通过请求转发，将数据流转给下一个servlet session:一次会话.一个用户的不同请求的数据共享。将数据从一次请求流转给其他请求 application:项目内.不同用户的数据共享问题。将数据从一个用户流转给其他用户 作用：数据流转 Jsp的路径在jsp中资源路径可以使用相对路径完成跳转，但是：问题一：资源的位置不可随意更改问题二：需要使用../进行文件夹的跳出。使用比较麻烦 使用绝对路径(必须会)/虚拟项目名/项目资源路径 12&lt;a href=&quot;/jsp/jspPro.jsp&quot;&gt;jspPro.jsp&lt;/a&gt;&lt;a href=&quot;/jsp/a/a.jsp&quot;&gt;a.jsp&lt;/a&gt;&lt;br /&gt; 注意：在jsp中资源的第一个/表示的是服务器根目录，相当于前面有http://localhost:8080 使用jsp中自带的全局路径声明12345&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;%&gt;&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; 作用：给资源前面添加项目路径http://127.0.0.1:8080/虚拟项目名/","link":"/2019/11/20/Jsp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BA%8C/"},{"title":"MyBatis实现动态SQL","text":"动态 SQL定义: 根据不同的条件需要执行不同的 SQL 命令 ps: MyBatis 中动态 SQL 的实现是通过在 mapper.xml 中添加逻辑判断 &lt;if&gt;12345678910&lt;select id=&quot;selByAccinAccout&quot; resultType=&quot;log&quot;&gt; select * from log where 1=1 &lt;!-- OGNL 表达式,直接写 key 或对象的属性.不需要添加任何特字符号 --&gt; &lt;if test=&quot;accin!=null and accin!=''&quot;&gt; and accin=#{accin} &lt;/if&gt; &lt;if test=&quot;accout!=null and accout!=''&quot;&gt; and accout=#{accout} &lt;/if&gt;&lt;/select&gt; &lt;where&gt; 当编写 where 标签时,如果内容中第一个是 and 去掉第一个 and 如果中有内容会生成 where 关键字,如果没有内容不生成 where 关键 代码示例1234567891011&lt;select id=&quot;selByAccinAccout&quot; resultType=&quot;log&quot;&gt; select * from log &lt;where&gt; &lt;if test=&quot;accin!=null and accin!=''&quot;&gt; and accin=#{accin} &lt;/if&gt; &lt;if test=&quot;accout!=null and accout!=''&quot;&gt; and accout=#{accout} &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; ps: 比直接使用&lt;if&gt;少写 where 1=1 &lt;choose&gt; &lt;when&gt; &lt;otherwise&gt; 只有有一个成立,其他都不执行 代码示例12345678910111213&lt;select id=&quot;selByAccinAccout&quot; resultType=&quot;log&quot;&gt; select * from log &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;accin!=null and accin!=''&quot;&gt; and accin=#{accin} &lt;/when&gt; &lt;when test=&quot;accout!=null and accout!=''&quot;&gt; and accout=#{accout} &lt;/when&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; ps:如果 accin 和 accout 都不是 null 或不是 “” 生成的 sql 中只有 where accin=?，即只有第一个选择分支生效 &lt;set&gt; 用在修改 SQL 中 set 从句中，去掉最后一个逗号 如果&lt;set&gt;里面有内容生成 set 关键字,没有就不生成 代码示例12345678910111213&lt;update id=&quot;upd&quot; parameterType=&quot;log&quot; &gt; update log &lt;set&gt; id=#{id}, &lt;if test=&quot;accIn!=null and accIn!=''&quot;&gt; accin=#{accIn}, &lt;/if&gt; &lt;if test=&quot;accOut!=null and accOut!=''&quot;&gt; accout=#{accOut}, &lt;/if&gt; &lt;/set&gt; where id=#{id}&lt;/update&gt; ps: id=#{id} 目的防止&lt;set&gt;中没有内容,mybatis 不生成 set 关键字,如果修改中没有 set 从句 SQL 语法错误 &lt;trim&gt; prefix 在前面添加内容 prefixOverrides 去掉前面内容 suffix 在后面添加内容 suffixOverrieds 去掉后面内容 执行顺序去掉内容后添加内容 代码示例1234567&lt;update id=&quot;upd&quot; parameterType=&quot;log&quot;&gt; update log &lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt; a=a, &lt;/trim&gt; where id=100&lt;/update&gt; &lt;bind&gt; 给参数重新赋值 场景:2.1 模糊查询2.2 在原内容前或后添加内容 代码示例1234&lt;select id=&quot;selByLog&quot; parameterType=&quot;log&quot; resultType=&quot;log&quot;&gt; &lt;bind name=&quot;accin&quot; value=&quot;'%'+accin+'%'&quot;/&gt; #{money}&lt;/select&gt; &lt;foreach&gt; 循环参数内容,还具备在内容的前后添加内容,还具备添加分隔符功能 适用场景:in 查询中，批量新增中(mybatis 中 foreach 效率比较低)2.1 如果希望批量新增,SQL 命令为insert into log VALUES(default,1,2,3),(default,2,3,4),(default,3,4,5)2.2 openSession()必须指定参数才能使用 底层 JDBC 的 PreparedStatement.addBatch(); factory.openSession(ExecutorType.BATCH); 代码示例3.1 collectino=&quot;&quot; 要遍历的集合3.2 item 迭代变量, #{迭代变量名}获取内容3.3 open 循环后左侧添加的内容3.4 close 循环后右侧添加的内容3.5 separator 每次循环时,元素之间的分隔符123456&lt;select id=&quot;selIn&quot; parameterType=&quot;list&quot; resultType=&quot;log&quot;&gt; select * from log where id in &lt;foreach collection=&quot;list&quot; item=&quot;abc&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #{abc} &lt;/foreach&gt;&lt;/select&gt; &lt;sql&gt; 和 &lt;include&gt;某些 SQL 片段如果希望复用,可以使用定义这个片段 123&lt;sql id=&quot;mysql&quot;&gt; id,accin,accout,money&lt;/sql&gt; 在&lt;select&gt;或&lt;delete&gt;或&lt;update&gt;或&lt;insert&gt;中使用&lt;include&gt;引用 123&lt;select id=&quot;&quot;&gt; select &lt;include refid=&quot;mysql&quot;&gt;&lt;/include&gt; from log&lt;/select&gt;","link":"/2020/02/03/MyBatis%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81SQL/"},{"title":"MyBatis实现多表查询","text":"Mybatis 实现多表查询方式 1.1 业务装配.对两个表编写单表查询语句,在业务(Service)把查询的两个结果进行关联 1.2 使用 Auto Mapping 特性,在实现两表联合查询时通过别名完成映射 1.3 使用 MyBatis 的&lt;resultMap&gt;标签进行实现 多表查询时,类中包含另一个类的对象的分类 2.1 单个对象 2.2 集合对象 resultMap标签 &lt;resultMap&gt;标签写在 mapper.xml 中,由程序员控制 SQL 查询结果与实体类的映射关系 使用&lt;resultMap&gt;标签时,&lt;select&gt;标签不写 resultType 属性,而是使用 resultMap 属性引用&lt;resultMap&gt;标签 MyBatis默认使用 Auto Mapping 特性 使用 resultMap 实现单表映射关系 数据库设计 1234create table teacher( id1 int(10) primary key auto_increment, name1 varchar(20)); 实体类设计 1234public class Teacher { private int id; private String name;} mapper.xml 代码 12345678910&lt;resultMap type=&quot;teacher&quot; id=&quot;mymap&quot;&gt; &lt;!-- 主键使用 id 标签配置映射关系 --&gt; &lt;id column=&quot;id&quot; property=&quot;id1&quot; /&gt; &lt;!-- 其他列使用 result 标签配置映射关系 --&gt; &lt;result column=&quot;name&quot; property=&quot;name1&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selAll&quot; resultMap=&quot;mymap&quot;&gt; select * from teacher&lt;/select&gt; 使用 resultMap 实现关联单个对象(N+1 方式) N+1 查询方式,先查询出某个表的全部信息,根据这个表的信息查询另一个表的信息 与业务装配的区别: 把在 service 里面写的代码,变成了由 mybatis 完成装配 实现步骤 3.1 在 Student 实现类中包含了一个 Teacher 对象 1234567public class Student { private int id; private String name; private int age; private int tid; private Teacher teacher;} 3.2 在 TeacherMapper 中提供一个查询 123&lt;select id=&quot;selById&quot; resultType=&quot;teacher&quot; parameterType=&quot;int&quot;&gt; select * from teacher where id=#{0}&lt;/select&gt; 3.3 在 StudentMapper 中配置映射关系 &lt;association&gt; 标签在装配一个对象时使用 property: 对象在类中的属性名 select: 通过哪个查询查询出这个对象的信息 column: 把当前表的哪个列的值做为参数传递给另一个查询 使用 N+1 方式时，如果列名和属性名相同可以不配置,直接使用 Auto mapping 特性 但是 mybatis 默认只会给列装配一次，需要装配多次的列必须配置1234567891011&lt;resultMap type=&quot;student&quot; id=&quot;stuMap&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;!-- 如果关联一个对象 --&gt; &lt;association property=&quot;teacher&quot; select=&quot;top.ljc.mapper.TeacherMapper.selById&quot; column=&quot;tid&quot;&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;selAll&quot; resultMap=&quot;stuMap&quot;&gt; select * from student&lt;/select&gt; 把上面代码简化成12345678&lt;resultMap type=&quot;student&quot; id=&quot;stuMap&quot;&gt; &lt;result column=&quot;tid&quot; property=&quot;tid&quot;/&gt; &lt;!-- 如果关联一个对象 --&gt; &lt;association property=&quot;teacher&quot; select=&quot;top.ljc.mapper.TeacherMapper.selById&quot; column=&quot;tid&quot;&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;selAll&quot; resultMap=&quot;stuMap&quot;&gt; select * from student&lt;/select&gt; 使用 resultMap 实现关联单个对象(联合查询方式)只需要编写一个 SQL,在 StudentMapper 中添加下面效果 &lt;association/&gt;只要装配一个对象时就用这个标签 此时把&lt;association/&gt;当成小的&lt;resultMap&gt;看待 javaType 属性: 指定&lt;association/&gt;装配完成后返回对象的类型，取值是一个类(或类的别名)12345678910111213&lt;resultMap type=&quot;Student&quot; id=&quot;stuMap1&quot;&gt; &lt;id column=&quot;sid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;sname&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;tid&quot; property=&quot;tid&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot; &gt; &lt;id column=&quot;tid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;tname&quot; property=&quot;name&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;selAll1&quot; resultMap=&quot;stuMap1&quot;&gt; select s.id sid,s.name sname,age age,t.id tid,t.name tname FROM student s left outer join teacher t on s.tid=t.id&lt;/select&gt; N+1方式和联合查询方式对比N+1: 需求不确定时联合查询: 需求中确定查询时两个表一定都查询 N+1 名称由来 举例:学生中有 3 条数据 需求:查询所有学生信息及授课老师信息 需要执行的 SQL 命令 1 查询全部学生信息: select * from 学生 2 执行 3 遍 select * from 老师 where id=学生的外键 使用多条 SQl 命令查询两表数据时,如果希望把需要的数据都查询出来,需要执行 N+1 条 SQl 才能把所有数据库查询出来 缺点: 效率低 优点: 如果有的时候不需要查询学生的同时查询老师,只需要执行一个 select * from student; 适用场景: 有的时候需要查询学生同时查询老师,有的时候只需要查询学生 如果解决 N+1 查询带来的效率低的问题 1 默认带的前提: 每次都是两个都查询 2 使用两表联合查询 使用&lt;resultMap&gt;查询关联集合对象(N+1) 在 Teacher 中添加 List 12345public class Teacher { private int id; private String name; private List&lt;Student&gt; list;} 在 StudentMapper.xml 中添加通过 tid 查询 123&lt;select id=&quot;selByTid&quot; parameterType=&quot;int&quot; resultType=&quot;student&quot;&gt; select * from student where tid=#{0}&lt;/select&gt; 在 TeacherMapper.xml 中添加查询全部&lt;collection/&gt; 是当属性是集合类型时使用的标签 12345678&lt;resultMap type=&quot;teacher&quot; id=&quot;mymap&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;collection property=&quot;list&quot; select=&quot;top.ljc.mapper.StudentMapper.selByTid&quot; column=&quot;id&quot;&gt;&lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;selAll&quot; resultMap=&quot;mymap&quot;&gt; select * from teacher&lt;/select&gt; 使用实现加载集合数据(联合查询方式)在 teacherMapper.xml 中添加 MyBatis 可以通过主键判断对象是否被加载过 不需要担心创建重复 Teacher12345678910111213&lt;resultMap type=&quot;teacher&quot; id=&quot;mymap1&quot;&gt; &lt;id column=&quot;tid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;tname&quot; property=&quot;name&quot;/&gt; &lt;collection property=&quot;list&quot; ofType=&quot;student&quot; &gt; &lt;id column=&quot;sid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;sname&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;tid&quot; property=&quot;tid&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;selAll1&quot; resultMap=&quot;mymap1&quot;&gt; select t.id tid,t.name tname,s.id sid,s.name sname,age,tid from teacher t LEFT JOIN student s on t.id=s.tid;&lt;/select&gt; 使用 Auto Mapping 结合别名实现多表查询 5.1 只能使用多表联合查询方式5.2 要求: 查询出的列名和属性名相同5.3 实现方式.在 SQL 是关键字符,两侧添加反单引号 123&lt;select id=&quot;selAll&quot; resultType=&quot;student&quot;&gt; select t.id `teacher.id`,t.name `teacher.name`,s.id id,s.name name,age,tid from student s LEFT JOIN teacher t on t.id=s.tid&lt;/select&gt;","link":"/2020/02/07/MyBatis%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"},{"title":"MyBatis接口绑定及多参数传递","text":"作用:实现创建一个接口后把 mapper.xml 由 mybatis 生成接口的实现类,通过调用接口对象就可以获取 mapper.xml 中编写的 sql ps:后面 mybatis 和 spring 整合时使用的是这个方案 实现步骤 创建一个接口 接口包名和接口名与 mapper.xml 中&lt;mapper&gt;标签的namespace属性值相同 接口中方法名和 mapper.xml 标签的 id 属性相同 在 mybatis.xml 中使用&lt;package&gt;进行扫描接口和 mapper.xml 代码实现步骤 在 mybatis.xml 中&lt;mappers&gt;下使用&lt;package&gt;123&lt;mappers&gt; &lt;package name=&quot;top.ljc.mapper&quot;/&gt;&lt;/mappers&gt; 在 top.ljc.mapper 下新建接口123public interface LogMapper { List&lt;Log&gt; selAll();} 在 top.ljc.mapper 新建一个 LogMapper.xml 1 namespace 必须和接口全限定路径(包名+类名)一致 2 id 值必须和接口中方法名相同 3 如果接口中方法为多个参数,可以省略 parameterType12345&lt;mapper namespace=&quot;top.ljc.mapper.LogMapper&quot;&gt; &lt;select id=&quot;selAll&quot; resultType=&quot;log&quot;&gt; select * from log &lt;/select&gt;&lt;/mapper&gt; 多参数实现办法 #{}中使用 0,1,2 或 param1,param2 在接口中声明方法1List&lt;Log&gt; selByAccInAccout(String accin,String accout); 在 mapper.xml 中添加1234&lt;!-- 当多参数时,不需要写 parameterType --&gt;&lt;select id=&quot;selByAccInAccout&quot; resultType=&quot;log&quot; &gt; select * from log where accin=#{0} and accout=#{1}&lt;/select&gt; 使用注解方式 在接口中声明方法1234567/*** mybatis 把参数转换为 map 了,其中@Param(&quot;key&quot;) 参数内容就是 map 的 value* @param accin123* @param accout3454235* @return*/List&lt;Log&gt; selByAccInAccout(@Param(&quot;accin&quot;) Stringaccin123,@Param(&quot;accout&quot;) String accout3454235); 在 mapper.xml 中添加 #{}里面写@Param(“内容”)参数中内容1234&lt;!-- 当多参数时,不需要写 parameterType --&gt;&lt;select id=&quot;selByAccInAccout&quot; resultType=&quot;log&quot; &gt; select * from log where accin=#{accin} and accout=#{accout}&lt;/select&gt;","link":"/2020/02/01/MyBatis%E6%8E%A5%E5%8F%A3%E7%BB%91%E5%AE%9A%E5%8F%8A%E5%A4%9A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"},{"title":"MyBatis注解","text":"注解: 为了简化配置文件 Mybatis 的注解简化 mapper.xml 文件 1 如果涉及动态 SQL 依然使用 mapper.xml mapper.xml 和注解可以共存 使用注解时 mybatis.xml 中&lt;mappers&gt;使用 1 &lt;package/&gt; 2 &lt;mapper class=&quot;&quot;/&gt; 实现查询@Select(&quot;select * from teacher&quot;) List&lt;Teacher&gt; selAll(); 实现新增@Insert(&quot;insert into teacher values(default,#{name})&quot;) int insTeacher(Teacher teacher); 实现修改@Update(&quot;update teacher set name=#{name} where id=#{id}&quot;) int updTeacher(Teacher teacher); 实现删除@Delete(&quot;delete from teacher where id=#{0}&quot;) int delById(int id); 使用注解实现&lt;resultMap&gt;功能 1 以 N+1 举例 2 在 StudentMapper 接口添加查询@Select(&quot;select * from student where tid=#{0}&quot;) List&lt;Student&gt; selByTid(int tid); 3 在 TeacherMapper 接口添加 @Results() 相当于&lt;resultMap&gt; @Result() 相当于&lt;id/&gt;或&lt;result/&gt; @Result(id=true) 相当于&lt;id/&gt; @Many() 相当于&lt;collection/&gt; @One() 相当于&lt;association/&gt;1234567@Results(value={ @Result(id=true,property=&quot;id&quot;,column=&quot;id&quot;), @Result(property=&quot;name&quot;,column=&quot;name&quot;), @Result(property=&quot;list&quot;,column=&quot;id&quot;,many=@Many(select=&quot;top.ljc.mapper.StudentMapper.selByTid&quot;))})@Select(&quot;select * from teacher&quot;)List&lt;Teacher&gt; selTeacher();","link":"/2020/02/08/MyBatis%E6%B3%A8%E8%A7%A3/"},{"title":"MyBatis环境搭建","text":"在IDEA中搭建WEB项目开发环境导入MyBatis所需jar包下载地址https://github.com/mybatis/mybatis-3/releases 各jar包作用 注意: 项目所需jar包全在mybatis/lib目录下 除mybatis所需jar包外还需要导入数据库驱动包 创建mybatis.xml全局配置文件引入 DTD 或 Schema（保证XML文件格式正确）在IDEA中可以从网络上抓取并自动配置，也可以手动配置本地dtd或schema mybatis.xml文件内容12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!-- 开启log4j日志支持 --&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!-- 给top.ljc.pojo包下的所有类取别名为类名(不区分大小写) --&gt; &lt;package name=&quot;top.ljc.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- default 引用 environment 的 id,当前所使用的环境 --&gt; &lt;environments default=&quot;default&quot;&gt; &lt;environment id=&quot;default&quot;&gt; &lt;!-- 使用原生JDBC事务 --&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据库源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;199827&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;package name=&quot;top.ljc.mapper&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; mapper包下创建”实体类名Mapper.xml”文件作用类似数据访问层实现类，在其中编写需要执行的SQL命令 文件内容12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namesapce:理解成实现类的全路径(包名+类名) --&gt;&lt;mapper namespace=&quot;&quot; &gt; &lt;!-- id:方法名 parameterType:定义参数类型 resultType:返回值类型 如果方法返回值是 list,在 resultType 中写 List 的泛型 因为 mybatis是对 jdbc 封装,一行一行读取数据 --&gt; &lt;select id=&quot;&quot; resultType=&quot;&quot;&gt; SQL &lt;/select&gt;&lt;/mapper&gt;","link":"/2020/01/19/MyBatis%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"MyBatis缓存机制","text":"应用程序和数据库交互的过程是一个相对比较耗时的过程 缓存存在的意义:让应用程序减少对数据库的访问,提升程序运行效率 MyBatis 中默认 SqlSession 缓存开启 同一个 SqlSession 对象调用同一个&lt;select&gt;时,只有第一次访问数据库,第一次之后把查询结果缓存到 SqlSession 缓存区(内存)中 缓存的是 statement 对象，简单记忆就是必须用一个&lt;select&gt;ps:在 myabtis 中一个&lt;select&gt;对应一个 statement 对象 有效范围必须是同一个 SqlSession 对象 缓存流程 步骤一: 先去缓存区中找是否存在 statement 步骤二:返回结果 步骤三:如果没有缓存 statement 对象,去数据库获取数据 步骤四:数据库返回查询结果 步骤五:把查询结果放到对应的缓存区中 SqlSessionFactory 缓存 SqlSessionFactory 缓存又叫做二级缓存 有效范围:同一个 factory 内任意 SqlSession 都可以获取 使用二级缓存的场景:数据频繁被使用,很少被修改 使用二级缓存步骤 1 在 mapper.xml 中添加&lt;cache readOnly=&quot;true&quot;&gt;&lt;/cache&gt; 2 如果不写 readOnly=”true”需要把实体类序列化 当 SqlSession 对象 close()时或 commit()时会把 SqlSession 缓存的数据刷(flush)到 SqlSessionFactory 缓存区中","link":"/2020/02/03/MyBatis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"},{"title":"MyBatis运行原理","text":"文字解释在 MyBatis 运行开始时需要先通过 Resources 加载全局配置文件 下面需要实例化SqlSessionFactoryBuilder 构建器，帮助 SqlSessionFactory 接口实现类 DefaultSqlSessionFactory 在实例化 DefaultSqlSessionFactory 之前需要先创建 XmlConfigBuilder解析全局配置文件流，并把解析结果存放在 Configuration 中 之后把 Configuratin 传递给 DefaultSqlSessionFactory 到此 SqlSessionFactory 工厂创建成功 再由 SqlSessionFactory 工厂创建 SqlSession 每次创建 SqlSession 时，都需要由 TransactionFactory 创建 Transaction 对象，同时还需要创建 SqlSession 的执行器 Excutor ，最后实例化 DefaultSqlSession ，传递给 SqlSession 接口 根据项目需求使用 SqlSession 接口中的 API 完成具体的事务操作 如果事务执行失败，需要进行 rollback 回滚事务 如果事务执行成功提交给数据库，关闭 SqlSession 到此就是 MyBatis 的运行原理(给面试官说的) 流程图 ![](http://cdn.liaojincan.top/202028153435.png\" width='400' height='900'/> ## 运行过程中涉及到的类 1. Resources MyBatis 中 IO 流的工具类 1.1 加载配置文件 2. SqlSessionFactoryBuilder() 构建器 2.1 作用:创建 SqlSessionFactory 接口的实现类 3. XMLConfigBuilder MyBatis 全局配置文件内容构建器类 3.1 作用负责读取流内容并转换为 JAVA 代码. 4. Configuration 封装了全局配置文件所有配置信息. 4.1 全局配置文件内容存放在 Configuration 中 5. DefaultSqlSessionFactory 是 SqlSessionFactory 接口的实现类 6. Transaction 事务类 6.1 每一个 SqlSession 会带有一个 Transaction 对象. 7. TransactionFactory 事务工厂 7.1 负责生产 Transaction 8. Executor MyBatis 执行器 8.1 作用:负责执行 SQL 命令 8.2 相当于 JDBC 中 statement 对象(或 PreparedStatement 或 CallableStatement) 8.3 默认的执行器 SimpleExcutor 8.4 批量操作 BatchExcutor 8.5 通过 openSession(参数控制) 9. DefaultSqlSession 是 SqlSession 接口的实现类 10. ExceptionFactory MyBatis 中异常工厂","link":"/2020/02/08/MyBatis%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"},{"title":"Servlet生命周期&amp;常见错误&amp;三个方法","text":"Servlet的生命周期 从第一次调用到服务器关闭。 如果Servlet在web.xml中配置了load-on-startup，生命周期为从服务器启动到服务器关闭 注意： init方法是对Servlet进行初始化的一个方法，会在Servlet第一次加载进行存储时执行 destory方法是在servlet被销毁时执行，也就服务器关闭时。 Servlet的常见错误404错误:资源未找到 在请求地址中的servlet的别名书写错误。 虚拟项目名称拼写错误 500错误：内部服务器错误 java.lang.ClassNotFoundException: top.ljc.servlet.ServletMothod解决：在web.xml中校验servlet类的全限定路径是否拼写错误。 因为service方法体的代码执行错误导致解决：根据错误提示对service方法体中的代码进行错误更改。405错误:请求方式不支持原因：请求方式和servlet中的方法不匹配所造成的。解决：尽量使用service方法进行请求处理，并且不要再service方法中调用父类的service。 service、doGet、doPost方法的区别Service方法：可以处理get/post方式的请求，如果servlet中有Service方法，会优先调用service方法对请求进行处理。 doGet方法：处理get方式的请求 doPost方法：处理post方式的请求 注意： 如果在覆写的service方法中调用了父类的service方法(super.service(arg0, arg1)),则service方法处理完后，会再次根据请求方式响应的doGet和doPost方法执行。所以，一般情况下，我们是不在覆写的service中调用父类的service方法的，避免出现405错误。","link":"/2019/11/13/Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF&%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95/"},{"title":"Servlet的请求转发与重定向&amp;Cookie技术","text":"请求转发作用：实现多个servlet联动操作处理请求，这样能避免代码冗余，让servlet的职责更加明确 使用：req.getRequestDispatcher(&quot;要转发的地址&quot;).forward(req, resp);地址：相对路径，直接书写servlet的别名即可 特点： 一次请求，浏览器地址栏信息不改变 请求转发后直接return结束即可 重定向作用：解决了表单重复提交的问题，以及当前servlet无法处理的请求的问题 使用：resp.sendRedirect(String uri); 时机： 如果请求中有表单数据，而数据又比较重要，不能重复提交，建议使用重定向 如果请求被Servlet接收后，无法进行处理，建议使用重定向定位到可以处理的资源 特点： 两次请求，两个request对象 浏览器地址栏信息改变 Cookie技术作用：解决了发送的不同请求的数据共享问题 Cookie的创建和存储： 创建Cookie对象Cookie c=new Cookie(String name, String value); 设置cookie(可选)设置有效期 c.setMaxAge(int seconds);设置有效路径 c.setPath(String uri); 响应Cookie信息给客户端resp.addCookie(c); Cookie的获取 获取Cookie信息数组Cookie[] cks=req.getCookies(); 遍历数组获取Cookie信息，使用for循环遍历即可，示例： 1234567if(cks!=null){ for(Cookie c:cks){ String name=c.getName(); String value=c.getValue(); System.out.println(name+&quot;:&quot;+value); }} 特点: 一个Cookie对象存储一条数据。多条数据，可以多创建几个Cookie对象进行存储。 浏览器端的数据存储技术。 存储的数据声明在服务器端。 临时存储:存储在浏览器的运行内存中，浏览器关闭即失效。 定时存储:设置了Cookie的有效期，存储在客户端的硬盘中，在有效期内符合路径要求的请求都会附带该信息。 默认cookie信息存储好之后，每次请求都会附带，除非设置有效路径","link":"/2019/11/20/Servlet%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91&Cookie%E6%8A%80%E6%9C%AF/"},{"title":"Session&amp;ServletContext&amp;ServletConfig","text":"一、Session技术作用：解决了一个用户的不同请求的数据共享问题 原理：用户第一次访问服务器，服务器会创建一个session对象给此用户，并将该session对象的JSESSIONID使用Cookie技术存储到浏览器中，保证用户的其他请求能够获取到同一个session象，也保证了不同请求能够获取到共享的数据 使用： 创建session对象/获取session对象HttpSession hs=req.getSession();注意： 如果请求中拥有session的标识符也就是JSESSIONID，则返回其对应的session队列 如果请求中没有session的标识符也就是JSESSIONID，则创建新的session对象，并将其JSESSIONID作为cookie数据存储到浏览器内存中 如果session对象失效了，也会重新创建一个session对象，并将其JSESSIONID存储在浏览器内存中 设置session存储时间hs.setMaxInactiveInterval(int seconds);注意：在指定的时间内session对象没有被使用则销毁，如果使用了则重新计时 设置session强制失效hs.invalidate(); 存储和获取数据存储：hs.setAttribute(String name,Object value);获取：hs.getAttribute(String name);，返回的数据类型为Object 注意：存储的动作和取出的动作发生在不同的请求中，但是存储要先于取出执行 特点： 数据存储在服务器端，由服务器进行创建session对象 session技术依赖Cookie技术 生命周期为一次会话，在JSESSIONID和SESSION对象不失效的情况下作用域为整个项目内 session对象在服务器端的默认存储时间是30分钟 JSESSIONID存储在了Cookie的临时存储空间中，浏览器关闭即失效 二、ServletContext对象作用：解决不同用户共享相同数据的问题 使用: 获取ServletContext对象123ServletContext sc=this.getServletContext();ServletContext sc2=this.getServletConfig().getServletContext();ServletContext sc3=req.getSession().getServletContext(); 使用ServletContext对象完成数据共享数据存储：sc.setAttribute(String name, Object value);数据获取：sc.getAttribute(&quot;str&quot;) ，返回的是Object类型 注意： 不同的用户可以给ServletContext对象进行数据的存取 获取的数据不存在返回null 特点: ServletContext由服务器创建，所有用户共享 生命周期为服务器开启到服务器关闭，作用域为整个项目内 三、ServletConfig对象作用：获取在web.xml中给每个servlet单独配置的数据 使用： 获取ServletConfig对象ServletConfig sc=this.getServletConfig(); 获取web.xml中的配置数据String code=sc.getInitParameter(&quot;config&quot;); 四、其他 获取项目中web.xml文件中的全局配置数据sc.getInitParameter(String name);根据键的名字返回web.xml中配置的全局数据的值，返回String类型，如果数据不存在返回null 获取项目webroot下的资源的绝对路String path=sc.getRealPath(String path); 获取的路径为项目根目录，path参数为项目根目录中的路径 获取webroot下的资源的流对象InputStream is = sc.getResourceAsStream(String path);此种方式只能获取项目根目录下的资源流对象，class文件的流对象需要使用类加载器获取，path参数为项目根目录中的路径","link":"/2019/11/20/Session&ServletContext&ServletConfig/"},{"title":"Socket","text":"Scoket是对TCP/IP协议的抽象，是操作系统对外开放的接口 Scoket通信流程 面试真题编写一个网络应用程序，有客户端与服务器端，客户端向服务器发送一个字符串，服务器收到该字符串后将其打印到命令行上，然后向客户端返回该字符串的长度，最后，客户端输出服务器端返回的该字符串的长度，分别用TCP和UDP种方式去实现 TCPTCPServer.java 1234567891011121314151617181920212223242526272829303132public class TCPServer { public static void main(String[] args) throws Exception{ //创建socket,并将socket绑定到65001端口 ServerSocket serverSocket = new ServerSocket(65001); //死循环，使得socket一直等待并处理客户端发送过来的请求 while (true) { //监听65000端口，直到客户端返回连接信息后才返回 Socket socket = serverSocket.accept(); //获取客户端的请求信息后，执行相关业务逻辑 new Thread(new Runnable() { @Override public void run() { try { OutputStream os = socket.getOutputStream(); InputStream is = socket.getInputStream(); int ch = 0; byte[] buffer = new byte[1024]; ch = is.read(buffer); String content = new String(buffer, 0, ch); System.out.println(content); os.write(new String(content.length() + &quot;&quot;).getBytes()); is.close(); os.close(); socket.close(); } catch (Exception e) { e.printStackTrace(); } } }).start(); } }} TCPClient.java 123456789101112131415161718public class TCPClient { public static void main(String[] args) throws Exception{ Socket socket = new Socket(&quot;127.0.0.1&quot;, 65001); OutputStream os = socket.getOutputStream(); InputStream is = socket.getInputStream(); os.write(&quot;Hello World!&quot;.getBytes()); byte[] buffer = new byte[1024]; int ch = is.read(buffer); String content = new String(buffer, 0, ch); System.out.println(content); is.close(); os.close(); socket.close(); }} UDPUDPServer.java 1234567891011121314151617181920212223242526272829303132public class UDPServer { public static void main(String[] args) throws Exception{ DatagramSocket socket = new DatagramSocket(65001); while (true) { new Thread(new Runnable() { @Override public void run() { try { // 服务端接受客户端发送的数据报 byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); byte[] data = packet.getData(); String content = new String(data, 0, packet.getLength()); System.out.println(content); byte[] sentContent = String.valueOf(content.length()).getBytes(); // 服务端给客户端发送数据报 DatagramPacket packetToClient = new DatagramPacket(sentContent, sentContent.length, packet.getAddress(), packet.getPort()); socket.send(packetToClient); } catch (Exception e) { e.printStackTrace(); } } }).start(); } }} UDPClient.java 123456789101112131415161718public class UDPClient { public static void main(String[] args) throws Exception{ DatagramSocket socket = new DatagramSocket(); byte[] buf = &quot;Hello World!&quot;.getBytes(); InetAddress address = InetAddress.getByName(&quot;127.0.0.1&quot;); DatagramPacket packet = new DatagramPacket(buf, buf.length, address, 65001); socket.send(packet); // 客户端接受服务端发送过来的数据报 byte[] data = new byte[100]; DatagramPacket receivedPacket = new DatagramPacket(data, data.length); socket.receive(receivedPacket); String content = new String(receivedPacket.getData(), 0, receivedPacket.getLength()); System.out.println(content); }}","link":"/2020/06/01/Socket/"},{"title":"Spring中常用注解","text":"@Component 创建类对象,相当于配置&lt;bean/&gt; @Service 与@Component 功能相同2.1 写在 ServiceImpl 类上 @Repository 与@Component 功能相同3.1 写在数据访问层类上 @Controller 与@Component 功能相同 1 写在控制器类上 @Resource(不需要写对象的 get/set)5.1 java 中的注解5.2 默认按照 byName 注入,如果没有名称对象,按照 byType 注入5.2.1 建议把对象名称和 spring 容器中对象名相同 @Autowired(不需要写对象的 get/set) 1 spring 的注解 2 默认按照 byType 注入 @Value() 获取 properties 文件中内容 @Pointcut() 定义切点 @Aspect() 定义切面类 @Before() 前置通知 @After 后置通知 @AfterReturning 后置通知,必须切点正确执行 @AfterThrowing 异常通知 @Arround 环绕通知","link":"/2020/02/27/Spring%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"},{"title":"Spring之AOP","text":"AOP AOP:中文名称面向切面编程 英文名称:(Aspect Oriented Programming) 正常程序执行流程都是纵向执行流程 3.1 面向切面编程,在原有纵向执行流程中添加横切面 3.2 不需要修改原有程序代码 高扩展性 原有功能相当于释放了部分逻辑，让职责更加明确 面向切面编程是什么? 在程序原有纵向执行流程中,针对某一个或某一些方法添加通知，形成横切面过程就叫做面向切面编程 常用概念 原有功能:切点，pointcut 前置通知:在切点之前执行的功能，before advice 后置通知:在切点之后执行的功能，after advice 如果切点执行过程中出现异常,会触发异常通知throws advice 所有功能总称叫做切面 织入:把切面嵌入到原有功能的过程叫做织入 实现AOP的两种放式 Schema-based 每个通知都需要实现接口或类 配置 spring 配置文件时在&lt;aop:config&gt;配置 AspectJ 每个通知不需要实现接口或类 配置 spring 配置文件是在&lt;aop:config&gt;的子标签&lt;aop:aspect&gt;中配置 基于Schema-based方式实现 导入 jar 新建通知类并实现接口 2.1 新建前置通知类 arg0: 切点方法对象 Method 对象 arg1: 切点方法参数 arg2:切点在哪个对象中123456public class MyBeforeAdvice implementsMethodBeforeAdvice { @Override public void before(Method arg0, Object[] arg1, Objectarg2) throws Throwable { System.out.println(&quot;执行前置通知&quot;); }} 2.2 新建后置通知类 arg0: 切点方法返回值 arg1:切点方法对象 arg2:切点方法参数 arg3:切点方法所在类的对象123456public class MyAfterAdvice implements AfterReturningAdvice {@Override public void afterReturning(Object arg0, Method arg1, Object[] arg2, Object arg3) throws Throwable { System.out.println(&quot;执行后置通知&quot;); }} 配置 spring 配置文件 3.1 引入 aop 命名空间 3.2 配置通知类的 3.3 配置切面 3.4 * 通配符,匹配任意方法名,任意类名,任意一级包名 3.5 如果希望匹配任意方法参数 (..) 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 配置通知类对象,在切面中引入 --&gt; &lt;bean id=&quot;mybefore&quot; class=&quot;top.ljc.advice.MyBeforeAdvice&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;myafter&quot; class=&quot;top.ljc.advice.MyAfterAdvice&quot;&gt;&lt;/bean&gt; &lt;!-- 配置切面 --&gt; &lt;aop:config&gt; &lt;!-- 配置切点 --&gt; &lt;aop:pointcut expression=&quot;execution(*top.ljc.test.Demo.demo2())&quot; id=&quot;mypoint&quot;/&gt; &lt;!-- 配置通知 --&gt; &lt;aop:advisor advice-ref=&quot;mybefore&quot; pointcut-ref=&quot;mypoint&quot;/&gt; &lt;aop:advisor advice-ref=&quot;myafter&quot; pointcut-ref=&quot;mypoint&quot;/&gt; &lt;/aop:config&gt; &lt;!-- 配置 Demo 类,测试使用 --&gt; &lt;bean id=&quot;demo&quot; class=&quot;top.ljc.test.Demo&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 编写测试代码123456789public class Test { public static void main(String[] args) { ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Demo demo = ac.getBean(&quot;demo&quot;,Demo.class); demo.demo1(); demo.demo2(); demo.demo3(); }} 运行结果demo1执行前置通知demo2执行后置通知demo3 使用 AspectJ 方式实现 新建类,不用实现接口 1.1 类中方法名任意123456789101112131415161718192021222324public class MyAdvice { public void mybefore(String name1,int age1){ System.out.println(&quot;前置&quot;+name1 ); } public void mybefore1(String name1){ System.out.println(&quot;前置:&quot;+name1); } public void myaftering(){ System.out.println(&quot;后置 2&quot;); } public void myafter(){ System.out.println(&quot;后置 1&quot;); } public void mythrow(){ System.out.println(&quot;异常&quot;); } public Object myarround(ProceedingJoinPoint p) throws Throwable{ System.out.println(&quot;执行环绕&quot;); System.out.println(&quot;环绕-前置&quot;); Object result = p.proceed(); System.out.println(&quot;环绕后置&quot;); return result; }} 配置 spring 配置文件 2.1 &lt;aop:after/&gt;后置通知,是否出现异常都执行 2.2 &lt;aop:after-returing/&gt;后置通知,只有当切点正确执行时执行 2.3 &lt;aop:after/&gt;,&lt;aop:after-returing/&gt;,&lt;aop:after-throwing/&gt;执行顺序和配置顺序有关 2.4 execution()括号中内容不能包括args 2.5 execution()表达式中间使用and，不能使用&amp;&amp;，应该让spring把and解析成&amp;&amp; 2.6 args(名称) 名称是自定义的，顺序和 demo1(参数,参数)对应 2.7 &lt;aop:before/&gt;中 arg-names=”名称”，名称来源于expression=””中 args()，名称必须一样 args() 有几个参数,arg-names 里面必须有几个参数 arg-names=””里面名称必须和通知方法参数名对应12345678&lt;aop:config&gt; &lt;aop:aspect ref=&quot;myadvice&quot;&gt; &lt;aop:pointcut expression=&quot;execution(*top.ljc.test.Demo.demo1(String,int)) and args(name1,age1)&quot; id=&quot;mypoint&quot;/&gt; &lt;aop:pointcut expression=&quot;execution(*top.ljc.test.Demo.demo1(String)) and args(name1)&quot; id=&quot;mypoint1&quot;/&gt; &lt;aop:before method=&quot;mybefore&quot; pointcut-ref=&quot;mypoint&quot; arg-names=&quot;name1,age1&quot;/&gt; &lt;aop:before method=&quot;mybefore1&quot; pointcut-ref=&quot;mypoint1&quot; arg-names=&quot;name1&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 使用注解(基于Aspect) spring 不会自动去寻找注解,必须告诉 spring 哪些包下的类中可能有注解引入xmlns:context&lt;context:component-scan base-package=&quot;top.ljc.advice&quot;&gt;&lt;/context:component-scan&gt; @Component 2.1 相当于&lt;bean/&gt; 2.2 如果没有参数,把类名首字母变小写,相当于&lt;bean id=””/&gt; 2.3 @Component(“自定义名称”)实现步骤 在 spring 配置文件中设置注解在哪些包中12&lt;context:component-scan base-package=&quot;top.ljc.advice,top.ljc.test&quot;&gt;&lt;/context:component-scan&gt; 在 Demo 类中添加@Componet 2.1 在方法上添加@Pointcut(“”) 定义切点123456789101112131415161718192021222324252627282930313233343536@Componentpublic class Demo { @Pointcut(&quot;execution(*top.ljc.test.Demo.demo1())&quot;) public void demo1() throws Exception{ //int i = 5/0; System.out.println(&quot;demo1&quot;); }}````3. 在通知类中配置 3.1 @Component 类被 spring 管理 3.2 @Aspect 相当于`&lt;aop:aspect/&gt;`表示通知方法在当前类中```java@Component@Aspectpublic class MyAdvice { @Before(&quot;top.ljc.test.Demo.demo1()&quot;) public void mybefore(){ System.out.println(&quot;前置&quot;); } @After(&quot;top.ljc.test.Demo.demo1()&quot;) public void myafter(){ System.out.println(&quot;后置通知&quot;); } @AfterThrowing(&quot;top.ljc.test.Demo.demo1()&quot;) public void mythrow(){ System.out.println(&quot;异常通知&quot;); } @Around(&quot;top.ljc.test.Demo.demo1()&quot;) public Object myarround(ProceedingJoinPoint p) throws Throwable{ System.out.println(&quot;环绕-前置&quot;); Object result = p.proceed(); System.out.println(&quot;环绕-后置&quot;); return result; }}","link":"/2020/02/27/Spring%E4%B9%8BAOP/"},{"title":"Spring之IoC&amp;DI","text":"IoCIoC，即 Inversion of Control (控制反转) IoC 将原先由程序员主动通过 new 实例化对象的工作转交给了 Spring 负责 控制反转中控制指的是：控制类的对象 控制反转中反转指的是：转交给 Spring 负责 IoC 最大的作用：解耦 (程序员不需要管理对象，解除了对象管理和程序员之间的耦合) DIDI，即 Dependency Injection（依赖注入） DI 和 IoC 是一样的 当一个类(A)中需要依赖另一个类()对象时，把 B 赋值给 A 的过程就叫做依赖注入 代码体现1234567&lt;bean id=&quot;peo&quot; class=&quot;top.ljc.pojo.People&quot;&gt; &lt;property name=&quot;desk&quot; ref=&quot;desk&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;desk&quot; class=&quot;top.ljc.pojo.Desk&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;property name=&quot;price&quot; value=&quot;12&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 给 Bean 的属性赋值(注入) 通过构造方法设置值 设置注入(通过 set 方法) 如果属性是基本数据类型或 String 等1234&lt;bean id=&quot;peo&quot; class=&quot;top.ljc.pojo.People&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 等价于 12345678&lt;bean id=&quot;peo&quot; class=&quot;top.ljc.pojo.People&quot;&gt; &lt;property name=&quot;id&quot;&gt; &lt;value&gt;456&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;name&quot;&gt; &lt;value&gt;zhangsan&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 如果属性是 Set&lt;?&gt;12345678&lt;property name=&quot;sets&quot;&gt; &lt;set&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;value&gt;4&lt;/value&gt; &lt;/set&gt;&lt;/property&gt; 如果属性是 List&lt;?&gt;1234567&lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; 如果 list 中就只有一个值 1&lt;property name=&quot;list&quot; value=&quot;1&quot;&gt;&lt;/property&gt; 如果属性是数组如果数组中就只有一个值,可以直接通过 value 属性赋值1234567&lt;property name=&quot;strs&quot; &gt; &lt;array&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/array&gt;&lt;/property&gt; 如果属性是 map123456&lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;a&quot; value=&quot;b&quot; &gt;&lt;/entry&gt; &lt;entry key=&quot;c&quot; value=&quot;d&quot; &gt;&lt;/entry&gt; &lt;/map&gt;&lt;/property&gt; 如果属性 Properties 类型123456&lt;property name=&quot;demo&quot;&gt; &lt;props&gt; &lt;prop key=&quot;key&quot;&gt;value&lt;/prop&gt; &lt;prop key=&quot;key1&quot;&gt;value1&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;","link":"/2020/02/24/Spring%E4%B9%8BIoC&DI/"},{"title":"Spring之自动注入&amp;properties文件加载","text":"自动注入 在 Spring 配置文件中对象名和 ref=”id”id 名相同使用自动注入,可以不配置&lt;property/&gt; 两种配置办法 2.1 在&lt;bean&gt;中通过 autowire=”” 配置,只对这个&lt;bean&gt;生效 2.2 在&lt;beans&gt;中通过 default-autowire=””配置,表当当前文件中所有&lt;bean&gt;都是全局配置内容 autowire=””可取值 3.1 default: 默认值,根据全局 default-autowire=””值，默认全局和局部都没有配置情况下，相当于 no 3.2 no: 不自动注入 3.3 byName: 通过名称自动注入，在 Spring 容器中找类的 Id 3.4 byType: 根据类型注入 pring容器中不可以出现两个相同类型的&lt;bean&gt; 3.5 constructor: 根据构造方法注入 提供对应参数的构造方法(构造方法参数中包含注入对戏那个) 底层使用 byName, 构造方法参数名和其他&lt;bean&gt;的 id相同 properties文件加载 在 src 下新建 xxx.properties 文件 在 spring 配置文件中先引入 xmlns:context,在下面添加 1 如果需要记载多个配置文件逗号分割1&lt;context:property-placeholder location=&quot;classpath:xxx.properties&quot;/&gt; 添加了属性文件记载,并且在&lt;beans&gt;中开启自动注入注意的地方 3.1 SqlSessionFactoryBean 的 id 不能叫做 sqlSessionFactory 3.2 修改 把原来通过 ref 引用替换成 value 赋值,自动注入只能影响ref,不会影响 value 赋值1234&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;&lt;property name=&quot;basePackage&quot; value=&quot;top.ljc.mapper&quot;&gt;&lt;/property&gt;&lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;factory&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 在被 Spring 管理的类中通过@Value(“${key}”)取出 properties 中内容 4.1 添加注解扫描 1&lt;context:component-scanbase-package=&quot;top.ljc.service.impl&quot;&gt;&lt;/context:component-scan&gt; 4.2 在类中添加 key 和变量名可以不相同 变量类型任意,只要保证 key 对应的 value 能转换成这个类型就可以12@Value(&quot;${my.demo}&quot;)private String test;","link":"/2020/02/27/Spring%E4%B9%8B%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5&properties%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/"},{"title":"Spring之声明式事务","text":"编程式事务 1.1 由程序员编程事务控制代码 1.2 OpenSessionInView 编程式事务 声明式事务 2.1 事务控制代码已经由 spring 写好.程序员只需要声明出哪些方法需要进行事务控制和如何进行事务控制 声明式事务都是针对于 ServiceImpl 类下方法的 事务管理器基于通知(advice)的 在spring配置文件中配置声明式事务123456789101112131415161718192021222324252627&lt;context:property-placeholder location=&quot;classpath:db.properties,classpath:second.properties&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- spring-jdbc.jar 中 --&gt;&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置声明式事务 --&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 哪些方法需要有事务控制 --&gt; &lt;!-- 方法以 ins 开头事务管理 --&gt; &lt;tx:method name=&quot;ins*&quot; /&gt; &lt;tx:method name=&quot;del*&quot; /&gt; &lt;tx:method name=&quot;upd*&quot; /&gt; &lt;tx:method name=&quot;*&quot; /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt;&lt;!-- 切点范围设置大一些 --&gt;&lt;aop:pointcut expression=&quot;execution(*top.ljc.service.impl.*.*(..))&quot; id=&quot;mypoint&quot; /&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;mypoint&quot; /&gt;&lt;/aop:config&gt; 声明式事务中属性解释 name=”” 哪些方法需要有事务控制 1.1 支持*通配符 readonly=”boolean” 是否是只读事务 2.1 如果为 true,告诉数据库此事务为只读事务.数据化优化,会对性能有一定提升,所以只要是查询的方法,建议使用此数据 2.2 如果为 false(默认值),事务需要提交的事务.建议新增,删除,修改 propagation 控制事务传播行为 3.1 REQUIRED (默认值): 如果当前有事务,就在事务中执行,如果当前没有事务,新建一个事务 3.2 SUPPORTS:如果当前有事务就在事务中执行,如果当前没有事务,就在非事务状态下执行 3.3 MANDATORY:必须在事务内部执行,如果当前有事务,就在事务中执行,如果没有事务,报错 3.4 REQUIRES_NEW:必须在事务中执行,如果当前没有事务,新建事务,如果当前有事务,把当前事务挂起 3.5 NOT_SUPPORTED:必须在非事务下执行,如果当前没有事务,正常执行,如果当前有事务,把当前事务挂起. 3.6 NEVER:必须在非事务状态下执行,如果当前没有事务,正常执行,如果当前有事务,报错 3.7 NESTED:必须在事务状态下执行.如果没有事务,新建事务,如果当前有事务,创建一个嵌套事务 isolation=””事务隔离级别 4.1 在多线程或并发访问下如何保证访问到的数据具有完整性的 4.2 脏读 一个事务(A)读取到另一个事务(B)中未提交的数据,另一个事务中数据可能进行了改变,此时 A 事务读取的数据可能和数据库中数据是不一致的,此时认为数据是脏数据,读取脏数据过程叫做脏读 4.3 不可重复读 主要针对的是某行数据(或行中某列) 主要针对的操作是修改操作 两次读取在同一个事务内 当事务 A 第一次读取事务后,事务 B 对事务 A 读取的淑君进行修改,事务 A 中再次读取的数据和之前读取的数据不一致,过程不可重复读 4.4 幻读 主要针对的操作是新增或删除 两次事务的结果. 事务 A 按照特定条件查询出结果,事务 B 新增了一条符合条件的数据.事务 A 中查询的数据和数据库中的数据不一致的,事务 A 好像出现了幻觉,这种情况称为幻读 4.5 DEFAULT: 默认值,由底层数据库自动判断应该使用什么隔离界别 4.6 READ_UNCOMMITTED: 可以读取未提交数据,可能出现脏读,不重复读,幻读，但效率最高 4.7 READ_COMMITTED:只能读取其他事务已提交数据.可以防止脏读,可能出现不可重复读和幻读 4.8 REPEATABLE_READ: 读取的数据被添加锁,防止其他事务修改此数据,可以防止不可重复读.脏读,可能出现幻读 4.9 SERIALIZABLE: 排队操作,对整个表添加锁.一个事务在操作数据时,另一个事务等待事务操作完成后才能操作这个表（是最安全的也是效率最低的） rollback-for=”异常类型全限定路径” 5.1 当出现什么异常时需要进行回滚 5.2 建议:给定该属性值，手动抛异常一定要给该属性值 no-rollback-for=”” 6.1 当出现什么异常时不滚回事务","link":"/2020/02/27/Spring%E4%B9%8B%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"title":"Spring创建对象的三种方式","text":"构造方法 无参构造创建：默认情况 有参构造创建：需要明确配置 2.1 需要在类中提供有参构造方法 2.2 在 applicationContext.xml 中设置调用哪个构造方法创建对象 如果设定的条件匹配多个构造方法执行最后的构造方法 index ：参数的索引,从 0 开始 name：参数名 type：类型(区分开关键字和封装类 int 和 Integer)12345678&lt;bean id=&quot;peo&quot; class=&quot;top.ljc.pojo.People&quot;&gt; &lt;!-- ref 引用另一个 bean value 基本数据类型或String等 --&gt; &lt;constructor-arg index=&quot;0&quot; name=&quot;id&quot; type=&quot;int&quot;value=&quot;123&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=&quot;1&quot; name=&quot;name&quot; type=&quot;java.lang.String&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 实例工厂 工厂设计模式：帮助创建类对象，一个工厂可以生产多个对象 实例工厂：需要先创建工厂，才能生产对象 实现步骤 3.1必须要有一个实例工厂 12345public class PeopleFactory { public People newInstance(){ return new People(1,&quot;测试&quot;); }} 3.2 在 applicationContext.xml 中配置工厂对象和需要创建的对象 12&lt;bean id=&quot;factory&quot; class=&quot;top.ljc.pojo.PeopleFactory&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;peo1&quot; factory-bean=&quot;factory&quot; factory-method=&quot;newInstance&quot;&gt;&lt;/bean&gt; 静态工厂 不需要创建工厂，快速创建对象 实现步骤 1 编写一个静态工厂(在方法上添加 static) 12345public class PeopleFactory { public static People newInstance(){ return new People(1,&quot;测试&quot;); }} 2.2 在 applicationContext.xml 中 1&lt;bean id=&quot;peo2&quot; class=&quot;top.ljc.pojo.PeopleFactory&quot; factory-method=&quot;newInstance&quot;&gt;&lt;/bean&gt;","link":"/2020/02/24/Spring%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"title":"Spring框架简介及官方压缩包目录","text":"主要发明者：Rod Johnson 轮子理论推崇者： 2.1 轮子理论：不用重复发明轮子 2.2 IT 行业：直接使用写好的代码 Spring 框架宗旨：不重新发明技术，让原有技术使用起来更加方便 Spring 几大核心功能 IoC/DI (控制反转/依赖注入) AOP (面向切面编程) 声明式事务 Spring 框架 runtime test： spring 提供测试功能 Core Container：核心容器(Spring 启动最基本的条件) 2.1 Beans ： Spring 负责创建类对象并管理对象 2.2 Core： 核心类 2.3 Context： 上下文参数，获取外部资源或者管理注解等 2.4 SpringEl： expression.jar AOP： 实现 aop 功能需要依赖 Aspects： 切面 AOP 依赖的包 Data Access/Integration： spring 封装数据访问层相关内容 5.1 JDBC：Spring 对 JDBC 封装后的代码 5.2 ORM：封装了持久层框架的代码， 例如 Hibernate 5.3 transactions：对应 spring-tx.jar，声明式事务使用 WEB：需要 spring 完成 web 相关功能时需要 6.1 例如：由 tomcat 加载 spring 配置文件时需要有 spring-web 包 PS： 从 Spring3 开始把 Spring 框架的功能拆分成多个 jar，Spring2 及以前就一个 jar Spring 框架中重要概念 容器(Container)： Spring 当作一个大容器 BeanFactory 接口(老版本) 2.1 新版本中 ApplicationContext 接口是 BeanFactory 的子接口，BeanFactory 的功能在 ApplicationContext 中都有","link":"/2020/02/11/Spring%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%98%E6%96%B9%E5%8E%8B%E7%BC%A9%E5%8C%85%E7%9B%AE%E5%BD%95/"},{"title":"Spring环境搭建","text":"在IDEA中搭建WEB项目开发环境下载jar包下载地址https://repo.spring.io/webapp/#/artifacts/browse/tree/General/libs-release-local/org/springframework/spring 导入核心包 spring-beans-4.1.6.RELEASE.jar spring-context-4.1.6.RELEASE.jar spring-core-4.1.6.RELEASE spring-expression-4.1.6.RELEASE.jar PS：此外，spring-framework工作还必须有 commons-logging-1.1.3.jar 在src下新建xml文件 xml文件名称和路径自定义，但建议名称为applicationContext.xml，路径在src下 applicationContext.xml 中配置的信息最终存储到了 AppliationContext 容器中 spring 配置文件是基于 schema 3.1 schema 文件扩展名.xsd 3.2 可以把 schema 理解成 DTD 的升级版（比 DTD 具备更好的扩展性） 3.3 每次引入一个 xsd 文件就是一个 namespace(xmlns) 配置文件中只需要引入基本 schema 4.1 通过&lt;bean/&gt;标签创建对象 4.2 默认在配置文件被加载时创建对象 实体类 1234public class People { private int id; private String name;} 配置文件 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- id设置对象的标识，class指定创建的类对象的全限定路径 --&gt; &lt;bean id=&quot;people&quot; class=&quot;top.ljc.pojo.People&quot;/&gt;&lt;/beans&gt; 创建测试类 getBean(“&lt;bean&gt;标签 id 值”,返回值类型)，如果没有第二个参数默认返回Object getBeanDefinitionNames()返回一个Spring容器中目前所有管理的所有对象的名称的数组 1234567public class Test { public static void main(String[] args) { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); People people = applicationContext.getBean(&quot;people&quot;, People.class); System.out.println(people); //People{id=0, name='null'} }} 至此，springframework基础环境搭建成功！","link":"/2020/02/11/Spring%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"MyBatis实现增删查改","text":"实体类数据库字段名与类属性相同 12345public class People { private int id; private String name; private int age;} 增123&lt;insert id=&quot;insOne&quot; parameterType=&quot;people&quot;&gt; insert into people values(default,#{name},#{age})&lt;/insert&gt; 1234567891011@Overridepublic int addPeople(People people) throws IOException { InputStream inputStream = Resources.getResourceAsStream(&quot;mybatis.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); int index = sqlSession.insert(&quot;top.ljc.mapper.PeopleMapper.insOne&quot;, people); sqlSession.commit(); sqlSession.close(); return index;} 删123&lt;delete id=&quot;delOneById&quot; parameterType=&quot;int&quot;&gt; delete from people where id=#{0}&lt;/delete&gt; 1234567891011@Overridepublic int delPeopleById(int id) throws IOException { InputStream inputStream = Resources.getResourceAsStream(&quot;mybatis.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); int index = sqlSession.insert(&quot;top.ljc.mapper.PeopleMapper.delOneById&quot;, id); sqlSession.commit(); sqlSession.close(); return index;} 查123&lt;select id=&quot;selAll&quot; resultType=&quot;top.ljc.pojo.People&quot;&gt; select * from people&lt;/select&gt; 1234567891011@Overridepublic List&lt;People&gt; show() throws IOException { InputStream inputStream = Resources.getResourceAsStream(&quot;mybatis.xml&quot;); //通过构建者设计模式实例化工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //通过工厂设计模式生产SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;People&gt; list = sqlSession.selectList(&quot;top.ljc.mapper.PeopleMapper.selAll&quot;); sqlSession.close(); return list;} 改123&lt;update id=&quot;updNameById&quot; parameterType=&quot;map&quot;&gt; update people set name=#{name} where id=#{id}&lt;/update&gt; 1234567891011121314@Overridepublic int updNameById(int id, String newName) throws IOException { InputStream inputStream = Resources.getResourceAsStream(&quot;mybatis.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;id&quot;, id); map.put(&quot;name&quot;, newName); int index = sqlSession.insert(&quot;top.ljc.mapper.PeopleMapper.updNameById&quot;, map); sqlSession.commit(); sqlSession.close(); return index;} 总结 在 mybatis 中默认是关闭了 JDBC 的自动提交功能 1 每一个 SqlSession 默认都是不自动提交事务 2 session.commit() 提交事务 3 设置自动提交：openSession(true)，setAutoCommit(true) mybatis 底层是对 JDBC 的封装. 1 JDBC 中 executeUpdate() 执行新增,删除,修改的 SQL 返回值为 int 类型,表示受影响的行数 2 mybatis 中 &lt;insert&gt; &lt;delete&gt; &lt;update&gt; 标签没有 resultType 属性,认为返回值都是 int 在 openSession() 时 Mybatis 会创建 SqlSession 1 同时会创建一个 Transaction(事务对象),且设置 autoCommit 为 false 2 如果出现异常，应该 session.rollback() 回滚事务","link":"/2020/01/21/MyBatis%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9/"},{"title":"TCP的三次握手与四次挥手","text":"传输控制协议TCP 面向连接的、可靠的、基于字节流的传输层通信协议 将应用层的数据流分割成报文段并发送给目标节点的TCP层 数据包都有序号,对方收到则发送ACK确认,未收到则重传 使用校验和来检验数据在传输过程中是否有误 TCP Flags URG :紧急指针标志 ACK :确认序号标志 PSH : push标志 RST :重置连接标志 SYN :同步序号,用于建立连接过程 FIN : finish标志,用于释放连接 TCP的三次握手 第一次握手建立连接时，客户端发送请求连接报文段到服务器，其中同步位SYN=1，同时选择了一个初始序号seq=x，客户端进入SYN_ SENT状态(同步已发送)，等待服务器确认 第二次握手服务器收到SYN包，如同意连接必须发送确认，SYN与ACK均为1 ，确认号ACK=x+1 ,同时为自己选择一个初始序号seq=y，服务器进入SYN_RECV状态(同步收到) 第三次握手客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1),同时seq=x+1，此包发送完毕后，客户端和服务器进入ESTABLISHED(已建立连接)状态，完成三次握手 为什么需要三次握手才能建立连接? 主要是为了初始化双方Sequence Number的值 防止已经失效的连接报文段又传送到BA发出的连接请求报文丢失（或超时）而未收到确认，A重传了连接请求报文并建立了连接，然后此时A第一次连接请求到达了B，如果没有第三次握手，那么B就会产生错误 首次握手的隐患，SYN超时 起因 Server收到Client的SYN ,回复SYN- ACK的时候未收到ACK确认 Server不断重试直至超时, Linux默认等待63秒才断开连接 针对SYN Flood的防护措施 SYN队列满后，通过tcp_ syncookies参数回发SYN Cookie 若为正常连接则Client会回发SYN Cookie，直接建立连接 建立连接后, Client出现故障怎么办？TCP含有保活机制，其作用原理如下 向对方发送保活探测报文,如果未收到响应则继续发送 尝试次数达到保活探测数仍未收到响应则中断连接 TCP的四次挥手 第一次挥手Client发送-一个FIN,用来关闭Client 到Server的数据传送，Client 进入FIN WAIT 1状态 第二次挥手Server 收到FIN后，发送-一个ACK给Client,确认序号为收到序号+1 (与SYN相同，一个FIN占用-一个序号)，Server 进入CLOSE _WAIT状态 第三次挥手Server发送-一个FIN,用来关闭Server到Client的数据传送，Server 进入LAST _ACK状态 第四次挥手Client 收到FIN后，Client 进入TIME _WAIT状态,接着发送一个ACK给Server,确认序号为收到序号+1,Server进入CLOSED状态，完成四次挥手 为什么会有TIME-WAIT状态？ 确保有足够的时间让服务器收到ACK包 避免新旧连接混淆 为什么需要四次握手才能断开连接因为TCP连接是全双工通信，发送方和接收方都需要FIN报文和ACK报文 服务器出现大量CLOSE_ WAIT状态的原因对方关闭socket连接,我方忙于读或写,没有及时关闭连接 检查代码,特别是释放资源的代码 检查配置,特别是处理请求的线程配置","link":"/2020/05/30/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"title":"TCP与UDP的区别","text":"UDP的特点 面向非连接 不维护连接状态,支持同时向多个客户端传输相同的消息 数据包报头只有8个字节,额外开销较小 吞吐量只受限于数据生成速率、传输速率以及机器性能 尽最大努力交付,不保证可靠交付,不需要维持复杂的链接状态表 面向报文,不对应用程序提交的报文信息进行拆分或者合并 TCP与UDP的区别 面向连接vs无连接TCP是面向连接的，UDP是无连接的 可靠性TCP是可靠的，UDP不保证可靠交付，只尽最大努力交互 有序性TCP是有序的，UDP是无序的 速度TCP传输速度相对于UDP较慢 量级TCP是重量级的，UDP是轻量级的","link":"/2020/05/31/TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"Ubuntu18.04配置&amp;美化","text":"Ubuntu18.04配置常用软件将语言改为中文(简体) 首先进入设置 找到Region&amp;Language，点击Manage Installed Languages 点击Install 输入用户名密码 等待Applying changes Install/Remove Languages… 找到中文(简体)Chinese(simplified)，点击Apply 等待Applying changes(需要一定的时间) 将下载好的中文(简体)按住鼠标拖拽到最上面 重新启动Ubuntu 18.04 登陆，进入到桌面，设置为“保留旧的名称”(勾选以后不再询问我) Ubuntu18.04使用图形界面换源 安装Chrome浏览器 下载好安装文件google-chrome-stable_current_amd64.deb 在文件所在位置打开终端，输入以下命令 1sudo dpkg -i google-chrome-stable_current_adm64.deb 安装搜狗拼音输入法 首先安装fcitx 切换输入法系统为fcitx后重启电脑 安装搜狗输入法 在搜狗输入法官网下载输入法安装文件sogoupinyin_2.2.0.0108_amd64.deb 在文件所在位置打开终端，输入以下命令 1sudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb 配置搜狗输入法为首选输入法 点击系统界面有右上角的键盘图标，然后点击配置，将输入法移动到首位即可 安装WPS 在WPS官网下载安装文件wps-office_11.1.0.8372_amd64.deb 在文件所在位置打开终端，输入以下命令 1sudo dpkg -i wps-office_11.1.0.8372_amd64.deb 解决字体缺失问题字体资源下载地址 https://pan.baidu.com/s/1codGNTwTAYb8JnGy-Kvxig解压字体资源并进入文件夹处打开终端输入下列命令 1sudo cp mtextra.ttf symbol.ttf WEBDINGS.TTF wingding.ttf WINGDNG2.ttf WINGDNG3.ttf /usr/share/fonts 安装wine-QQ2019-10-30 16:47:34 — QQ官方出Linux版了，可以直接用官方的不搞这个了 安装deepin-wine环境上https://github.com/wszqkzqk/deepin-wine-ubuntu页面下载zip包（或用git方式克隆），解压到本地文件夹，在文件夹中打开终端，输入sudo sh ./install.sh一键安装。 安装相关应用容器在http://mirrors.aliyun.com/deepin/pool/non-free/d/中下载想要的容器，点击deb安装即可。以下为推荐容器，任选其一即可:TIM：http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.office/QQ：http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/QQ轻聊版：http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im.light/ 解决QQ最小化托盘图标问题在软件商店中搜索并安装 Gnome Shell 插件：TopIcons Plus Ubuntu18.04界面美化安装Gnome-tweak-tool统一管理各种美化操作1sudo apt-get install gnome-tweak-tool 在Ubuntu软件商店里面搜索安装各种插件 Dash to dock 设置让图标从界面左边变成界面底部居中或者其他位置 可以通过设置使图标栏背景透明 智能隐藏显示图标 User theme 使shell主题可以使用桌面主题(shell即为顶部栏，shell主题和桌面主题不一样，是个单独的模块) Hide top bar 可以设置自动隐藏顶部栏，因为18.04应用上框不会和顶部栏合并，比较占面积 TopIcons Plus 在任务通知栏位置为部分应用形成一个个的图标，例如Wine-QQ Dynamic Top Bars 使顶部栏透明，界面整体效果更加舒爽","link":"/2019/11/14/Ubuntu18.04%E9%85%8D%E7%BD%AE&%E7%BE%8E%E5%8C%96/"},{"title":"TomcatJDBCPool数据库连接池","text":"数据库连接池 所做工作：在内存中开辟了一块空间,存放多个数据库连接对象 数据库连接池中数据库连接对象的状态 active态:当前连接对象被应用程序使用中 Idle空闲状态:等待应用程序使用 使用数据库连接池的目的在高频率访问数据库时,使用数据库连接池可以降低服务器系 统压力,提升程序运行效率 注意：小型项目不适用数据库连接池 JDBC Tomcat Pool这是一个直接由 tomcat 产生数据库连接池 在WEB项目中创建META-INF目录META-INF目录与WEB-INF目录同级 在META-INF目录下创建context.xml123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Context&gt; &lt;Resource driverClassName=&quot;com.mysql.cj.jdbc.Driver&quot; url=&quot;jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC&quot; username=&quot;root&quot; password=&quot;199827&quot; maxActive=&quot;50&quot; maxIdle=&quot;20&quot; name=&quot;test&quot; auth=&quot;Container&quot; maxWait=&quot;10000&quot; type=&quot;javax.sql.DataSource&quot; /&gt; &lt;!-- driverClassName JDBC驱动名 url 数据库地址 username 数据库用户名 password 数据库用户密码 maxActive 最大活跃数据库对象 maxIdle 最大等待数据库对象 name 当前数据库连接的识别名 auth 认证 maxWait 新请求等待时间 type 返回的数据类型 --&gt;&lt;/Context&gt; 获取数据库连接池1234567891011121314151617181920212223242526272829303132333435@WebServlet(urlPatterns = &quot;/pool&quot;, name = &quot;pool&quot;)public class DemoServlet extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //设置请求编码格式 req.setCharacterEncoding(&quot;utf-8&quot;); //设置响应编码格式 resp.setContentType(&quot;text/html;charset=utf-8&quot;); try { //获取上下文 Context context = new InitialContext(); //获取数据库连接池 DataSource dataSource = (DataSource) context.lookup(&quot;java:comp/env/test&quot;); //从数据库连接池获取数据库连接 Connection connection = dataSource.getConnection(); PreparedStatement preparedStatement = connection.prepareStatement(&quot;select * from flower&quot;); ResultSet resultSet = preparedStatement.executeQuery(); PrintWriter printWriter = resp.getWriter(); while (resultSet.next()){ printWriter.print(resultSet.getInt(1)+&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;+resultSet.getString(2)+&quot;&lt;br/&gt;&quot;); } printWriter.flush(); printWriter.close(); resultSet.close(); } catch (NamingException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } }} 注意： 使用Tomcat JDBC Pool仍然需要在项目下导入数据库的JDBC驱动包 在普通java类无法调用Tomcat JDBC Pool，必须在要发布到Tomcat容器中的java类中使用","link":"/2019/12/05/TomcatJDBCPool%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"},{"title":"git常用命令","text":"git init把当前目录变成Git可以管理的仓库 git add 文件名告诉Git，把文件添加到仓库 git commit -m “提交说明”告诉Git，把文件提交到仓库 git status掌握仓库当前的状态 git diff查看difference git log查看提交的历史记录 git reset –hard HEAD^回退到上一个版本 git reset –hard 版本号回退到指定版本 git reflog查看命令历史(与HEAD指针有关的)","link":"/2019/11/14/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"parameterType&amp;获取参数内容&amp;别名","text":"parameterType 在XXXMapper.xml中，&lt;select&gt;&lt;delete&gt;&lt;update&gt;等标签的parameterType属性可以控制参数类型 SqlSession的selectList()和selectOne()的第二个参数以及selectMap()的第三个参数都表示方法的参数 示例通过id查询人员详细信息，传递的参数是整数类型，返回值类型是自定义的People实体类 123&lt;select id=&quot;selById&quot; parameterType=&quot;int&quot; resultMap=&quot;people&quot;&gt; select * from people where id = #{0}&lt;/select&gt; 12People p = session.selectOne(&quot;a.b.selById&quot;,1);System.out.println(p); 获取参数内容#{}获取参数内容 使用索引,从 0 开始 #{0}表示第一个参数 也可以使用#{param1}第一个参数 如果只有一个参数(基本数据类型或 String),mybatis对#{}里面内容没有要求只要写内容即可 如果参数是对象#{属性名} 如果参数是 map 写成#{key} ${}获取参数内容与#{}获取参数语法一致 #{}和${}的区别 #{}获取参数的内容支持索引获取,param1获取指定位置参数，并且 SQL 使用?占位符 ${} 字符串拼接不使用?占位符,默认找${内容}内容的get/set方法,如果写数字,就是一个数字 typeAliases别名给某个类起别名alias属性指定别名名称，如不填写，系统默认将类名的全小写作为别名 123&lt;typeAliases&gt; &lt;typeAlias type=&quot;top.ljc.pojo.People&quot; alias=&quot;peo&quot;/&gt;&lt;/typeAliases&gt; 给某个包下的所有类起别名别名为类名,且不区分大小写 123&lt;typeAliases&gt; &lt;package name=&quot;top.ljc.pojo&quot; /&gt;&lt;/typeAliases&gt;","link":"/2020/01/20/parameterType&%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E5%86%85%E5%AE%B9&%E5%88%AB%E5%90%8D/"},{"title":"request&amp;response对象","text":"request对象作用：request对象中封存了当前请求的所有请求信息 注意：request对象由tomcat服务器创建，并作为实参传递给处理请求的servlet的service方法。 获取请求头数据1234req.getMethod();//获取请求方式req.getRequestURL();//获取请求URL信息req.getRequestURI();//获取请求URI信息req.getScheme();//获取协议 获取请求行数据12req.getHeader(&quot;键名&quot;);//返回指定的请求头信息req.getHeaderNames();//返回请求头的键名的枚举集合 获取用户数据123req.getParameter(&quot;键名&quot;);//返回指定的用户数据req.getParameterValues(&quot;键名&quot;);//返回同键不同值的请求数据(多选)，返回的数组req.getParameterNames()//返回所有用户请求数据的枚举集合 注意：如果要获取的请求数据不存在，不会报错，会返回null response对象作用：用来响应数据到浏览器的一个对象 设置响应头12setHeader(String name,String value);//在响应头中添加响应信息，但是同键会覆盖addHeader(String name,String value);//在响应头中添加响应信息，但是不会覆盖。 设置响应状态1sendError(int num,String msg);//自定义响应状态码。 设置响应实体1resp.getWrite().write(String str);//响应具体的数据给浏览器 设置响应编码格式1resp.setContentType(&quot;text/html;charset=utf-8&quot;);","link":"/2019/11/13/request&response%E5%AF%B9%E8%B1%A1/"},{"title":"单例设计模式","text":"作用: 在应用程序有保证最多只能有一个实例 优点 2.1 提升运行效率 2.2 实现数据共享，例如application 对象 懒汉式 对象只有被调用时才去创建 由于添加了锁,所以效率低 示例代码1234567891011121314151617181920212223242526272829303132public class SingleTon { //由于对象需要被静态方法调用,把方法设置为 static //由于对象是 static,必须要设置访问权限修饰符为 private,如果是 public 可以直接调用对象,不执行访问入口 private static SingleTon singleton; /** * 方法名和类名相同 * 无返回值 * 其他类不能实例化这个类对象 * 对外提供访问入口 */ private SingleTon(){} /** * 实例方法,实例方法必须通过对象调用 * 设置方法为静态方法 * @return */ public static SingleTon getInstance(){ //添加逻辑如果实例化过,直接返回 if(singleton==null){ /* * 多线程访问下,可能出现 if 同时成立的情况,添加锁 */ synchronized (SingleTon.class) { //双重验证 if(singleton==null){ singleton = new SingleTon(); } } } return singleton; }} 饿汉式解决了懒汉式中多线程访问可能出现同一个对象和效率低问题12345678public class SingleTon { //在类加载时进行实例化 private static SingleTon singleton=new SingleTon(); private SingleTon(){} public static SingleTon getInstance(){ return singleton; }}","link":"/2020/02/27/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"代理设计模式","text":"设计模式:前人总结的一套解决特定问题的代码 代理设计模式优点 2.1 保护真实对象 2.2 让真实对象职责更明确 2.3 扩展 代理设计模式 3.1 真实对象(老总) 3.2 代理对象(秘书) 3.3 抽象对象(抽象功能),谈小目标s静态代理设计模式 由代理对象代理所有真实对象的功能 1 自己编写代理类 2 每个代理的功能需要单独编写 静态代理设计模式的缺点 1 当代理功能比较多时,代理类中方法需要写很多动态代理 为了解决静态代理频繁编写代理功能缺点 分类 2.1 JDK 提供的 2.2 cglib 动态代理JDK 动态代理 和 cglib 动态代理对比 1.1 优点：jdk 自带,不需要额外导入jar 1.2 缺点: 真实对象必须实现接口 利用反射机制，效率不高 使用 JDK 动态代理时可能出现java.lang.ClassCastException异常 1 出现原因:希望把接口对象转换为具体真实对象cglib动态代理 cglib 优点 1.1 基于字节码,生成真实对象的子类，运行效率高于 JDK 动态代理 1.2 不需要实现接口 cglib 缺点：非JDK功能，需要额外导入 jar 使用 spring aop 时,只要出现 Proxy 和真实对象转换异常 3.1 设置为 true 使用 cglib 3.2 设置为 false 使用 jdk(默认值)&lt;aop:aspectj-autoproxyproxy-target-class=&quot;true&quot;&gt;&lt;/aop:aspectj-autoproxy&gt;","link":"/2020/02/27/%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"命名规范&amp;MVC","text":"命名规范 项目名：不使用中文，无其他要求 包：公司（个人）域名倒写 数据访问层：dao,persist,mapper 实体：entity,model,bean,javabean,pojo 业务逻辑：service,biz 控制器：controller,servlet,action,web 过滤器：filter 异常：exception 监听器：listener 注释： 在类和方法上使用文档注释/** */ 在方法里面使用/* */或// 类：大驼峰 方法：小驼峰 注意：一般异常是在数据访问层和控制层进行处理，业务层只将异常抛出 MVC开发模式 M：Model 模型，实体类，业务，dao V：view 视图，JSP C：Controller 控制器，servlet 作用：视图和逻辑分离 MVC开发模式适用场景：大型项目的开发，越往底层复用越高 图实例 先设计数据库 其次实体类 再者数据访问层 再写业务逻辑 再就是写控制器 最后写视图","link":"/2019/12/02/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83&MVC/"},{"title":"newifi mini刷Breed与PandoraBox","text":"刷机所用路由器 —— newifi mini 刷机所用固件(注意下载路由器对应的版本) Breed下载地址https://www.right.com.cn/forum/thread-161906-1-1.htmlhttps://breed.hackpascal.net/ PandoraBox下载地址http://downloads.openwrt.org.cn/PandoraBox/ 刷Breed刷了Breed固件，再从Breed固件刷其它第三方固件不容易变砖 准备一根网线，一端连电脑，一端连Newifi任意一个网口(LAN) 设置电脑IP地址为192.168.1.88，子网掩码为255.255.255.0 按住Newifi的Reset键不放，接通Newifi电源，等6秒后(指示灯闪烁后)再松开Reset键 电脑浏览器访问192.168.1.1，进入Newifi恢复模式界面 选择对应Newifi相应的Breed固件，点击恢复按钮，等待升级完毕。注意：升级过程中一定别断开电源，不然大概率变砖(亲测) 刷第三方固件PandoraBox(OpenWrt的分支) 进入Breed Web恢复控制台界面a. 拔掉电源b. 按住Reset键不放c. 接通电源d. 6秒后松开Reset键e. 访问192.168.1.1进入Breed界面Tips:无法进入Breed界面时可尝试先将电脑IP恢复为自动获取 备份原始固件(EEPRON和编程器固件) 到固件更新页面选择固件，选择第三方固件文件，点击上传 点击上传后会有一个确认页面，核对无误后继续，等待更新完成 将电脑IP恢复为自动获取，再次进入192.168.1.1，输入密码admin跳转PandoraBox管理界面 到此，路由器刷Breed与PandoraBox成功完成！","link":"/2019/05/11/newifi-mini%E5%88%B7Breed%E4%B8%8EPandoraBox/"},{"title":"在IDEA中搭建WEB项目开发环境","text":"创建项目记得要勾选Web Application 在WEB-INF目录下创建文件夹libs和classes libs:放置项目所需的各种.jar文件 classes:存放src下源文件编译后生成的类生成文件 将libs和classes文件夹与项目关联设置类生成文件输出路径为刚才创建的classes文件夹设置刚才创建的libs文件夹为存放.jar文件的文件夹IEDA没有工具栏的可以按照下图开启toolbar 配置Tomcat本地容器创建Tomcat本地容器以热部署方式部署项目到Tomcat容器中","link":"/2019/12/05/%E5%9C%A8IDEA%E4%B8%AD%E6%90%AD%E5%BB%BAWEB%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"title":"在项目中引入Log4j日志支持","text":"下载jar包下载地址：http://mirrors.tuna.tsinghua.edu.cn/apache/logging/log4j/2.13.0/apache-log4j-2.13.0-bin.zip 将下载文件中的log4j-api-2.13.0.jar和log4j-core-2.13.0.jar导入项目 在src下创建log4j.properties文件内容1234567891011log4j.rootCategory=Info, CONSOLE ,LOGFILElog4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern=%C %d{YYYY-MM-dd hh:mm:ss} %m %nlog4j.appender.LOGFILE=org.apache.log4j.FileAppenderlog4j.appender.LOGFILE.File=E:/my.loglog4j.appender.LOGFILE.Append=truelog4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayoutlog4j.appender.LOGFILE.layout.ConversionPattern=%m %n 解析 第一行控制输出级别和输出目的地 输出级别：fatal(致命错误) &gt; error (错误) &gt; warn (警告) &gt; info(普通信息) &gt; debug(调试信息) 输出目的地：控制台（CONSOLE）、日志文件（LOGFILE） ConversionPattern与表达式共同控制输出内容 常用表达式 %C 包名+类名 %d{YYYY-MM-dd HH:mm:ss} 时间 %L 行号 %m 信息 %n 换行 log4j.appender.LOGFILE.File控制输出的日志文件的路径和名称（文件扩展名为.log）","link":"/2020/01/19/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%95%E5%85%A5Log4j%E6%97%A5%E5%BF%97%E6%94%AF%E6%8C%81/"},{"title":"安装Ubuntu18.04虚拟机与VMwareTools","text":"安装Ubuntu18.04虚拟机VMware15（32/64）位下载地址：12pan.baidu.com/s/1bTFt1hhPHIZ5YFbatN95bw提取码: t4v3 使用VMware创建一个虚拟机 安装Ubuntu18.04系统 解决成功重启后无法进入系统的问题 最终安装成功示例 安装VMwareToolsVMwareTools作用： 增强虚拟显卡和硬盘性能、以及同步虚拟机与主机时钟的驱动程序。 可以从物理主机直接往虚拟机里面拖文件。 鼠标进入虚拟机后可以直接出来，无需按CTRL+ALT才可以释放鼠标。 可以解决Ubuntu主窗口分辨率不适应问题，可自动改成适当的分辨率。 安装步骤 安装VMwareTools后仍旧无法自适应窗口大小（调整设置如下图所示）","link":"/2019/11/14/%E5%AE%89%E8%A3%85Ubuntu18.04%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8EVMwareTools/"},{"title":"安装Windows10&amp;Ubuntu18.04双系统","text":"最终效果 准备工作从磁盘分出分出100G空闲空间右键点击我的电脑，然后点击管理点击磁盘管理选择一个大容量的分区（不要选择Windows10的系统分区），右键，选择压缩卷，从磁盘分出分出100G空闲空间 准备空白U盘和Ubuntu18.04镜像文件百度Ubuntu18.04镜像，下载即可，下载完成后，将文件解压缩到空白U盘 安装过程 插上制作好的U盘，重启电脑 进入BIOS（一般都是刚开机就一直按F2），关闭Security Boot选项，再次重启电脑 进入引导选择界面（一般都是刚开机就一直按F12），选择自己制作的那个U盘 此时就进入了Ubuntu18.04的系统安装引导界面，后续步骤参照虚拟机安装Ubuntu系统，仅需要注意选择安装位置时一定要选择我们之前准备好的那100G空闲空间","link":"/2019/11/14/%E5%AE%89%E8%A3%85Windows10&Ubuntu18.04%E5%8F%8C%E7%B3%BB%E7%BB%9F/"},{"title":"计算机网络体系结构","text":"计算机网络体系结构网络的体系结构：计算机网络各层及其协议的集合 OSI七层协议 业界提出来的参考框架，没有具体实现，是法律上的国际标准 TCP/IP四层协议 事实上的国际标准，有具体实现 网络接口层 网际层IP 运输层 应用层 五层协议 物理层比特流透明的传输确定与传输媒体接口相关的特性 数据链路层差错检测，普遍使用循环冗余检验CRC封装成帧，给数据加上帧首部和尾部透明传输，数据部分控制字符转义 网路层主机间通信 运输层主机进程之间的可靠通信 应用层规定了引用进程间的通信和交互规则","link":"/2020/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"title":"超时重传时间的选择与TCP的滑动窗口","text":"超时重传时间的选择RTT : 报文段的往返时间RTTS : 加权平均往返时间，也称平滑的往返时间 第一次测量到RTT样本时，RTTS 值就取该样本 此后按下列式子进行计算 新的RTTS = (1 - α) * (旧的RTTS) + α * (新的RTT样本) 建议标准 RFC 6289 推荐的α值为 1/8 RTO : 超时重传时间RTTD : RTT的偏差的加权平均值 第一次测量时，RTTD 取RTT样本值的一半 此后按下列式子进行计算 新的RTTD = (1 - β) * (旧的RTTD) + β * |RTTS - 新的RTT样本| 建议标准 RFC 6289 推荐的β值为 1/4 *RTO = RTTS + 4 * RTTD* TCP的滑动窗口基于确认重传机制，主要功能是流量控制和乱序重排 AdvertisedWindow = MaxRcvBuffer - (LastByteRcvd - LastByteRead) EffectiveWindow = AdvertisedWindow - (LastByteSent - LastByteAcked)","link":"/2020/05/31/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%80%89%E6%8B%A9%E4%B8%8ETCP%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"title":"使用Spring简化MyBatis","text":"导包![](http://cdn.liaojincan.top/2020224090838.png&quot; width=’200’ height=’400’/&gt; mybatis所有jar，spring基本包，spring-jdbc，spring-tx，spring-aop，spring-web，spring整合mybatis的包 配置 web.xml1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;3.0&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;&gt; &lt;!-- 上下文参数 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- spring 配置文件 --&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 封装了一个监听器,帮助加载 Spring 的配置文件爱 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 编写spring配置文件applicationContext.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 数据源封装类 .数据源:获取数据库连接,spring-jdbc.jar 中 --&gt; &lt;bean id=&quot;dataSouce&quot; class=&quot;org.springframework.jdbc.datasource.DriverMan gerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ssm&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;smallming&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 创建 SqlSessionFactory 对象 --&gt; &lt;bean id=&quot;factory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 数据库连接信息来源于 dataSource --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSouce&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 扫描器相当于 mybatis.xml 中 mappers 下 package 标签, 扫描 top.ljc.mapper 包后会给对应接口创建对象 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 要扫描哪个包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;top.ljc.mapper&quot;&gt;&lt;/property&gt; &lt;!-- 和 factory 产生关系 --&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;factory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 由 spring 管理 service 实现类 --&gt; &lt;bean id=&quot;airportService&quot; class=&quot;top.ljc.service.impl.AirportServiceImpl&quot;&gt; &lt;property name=&quot;airportMapper&quot; ref=&quot;airportMapper&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 编写代码 正常编写 pojo 编写 mapper 包下时必须使用接口绑定方案或注解方案(必须有接口) 正常编写 Service 接口和 Service 实现类 1 需要在 Service 实现类中声明 Mapper 接口对象,并生成get/set 方法 spring 无法管理 Servlet,在 service 中取出 Servie 对象 1234567891011121314151617181920@WebServlet(&quot;/airport&quot;)public class AirportServlet extends HttpServlet{ private AirportService airportService; @Override public void init() throws ServletException { //对 service 实例化 //ApplicationContext ac = newClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //spring 和 web 整合后所有信息都存放在 webApplicationContext ApplicationContext ac = WebApplicationContextUtils.getRequiredWebApplicationContext(getServletContext()); airportService=ac.getBean(&quot;airportService&quot;,AirportServiceImpl.class); } @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException,IOException { req.setAttribute(&quot;list&quot;, airportService.show()); req.getRequestDispatcher(&quot;index.jsp&quot;).forward(req,resp); }}","link":"/2020/02/24/%E4%BD%BF%E7%94%A8Spring%E7%AE%80%E5%8C%96MyBatis/"}],"tags":[{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"计算机网路","slug":"计算机网路","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/"},{"name":"Servlet&amp;Jsp","slug":"Servlet-Jsp","link":"/tags/Servlet-Jsp/"},{"name":"MyBatis","slug":"MyBatis","link":"/tags/MyBatis/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"搞事情","slug":"搞事情","link":"/tags/%E6%90%9E%E4%BA%8B%E6%83%85/"},{"name":"JavaEE","slug":"JavaEE","link":"/tags/JavaEE/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[]}